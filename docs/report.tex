\documentclass[a4paper,12pt]{report}

\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{hyperref}
\usepackage{tikz}

% Questo commentalo se vuoi scrivere in inglese.
\usepackage[italian]{babel}

\usepackage[italian]{cleveref}

\title{Progetto di Programmazione ad Oggetti\\``The Exiled''}

\author{Luca Casadei, Francesco Pazzaglia, Marco Magnani, Manuel Baldoni}
\date{\today}


\begin{document}

\maketitle

\tableofcontents

\chapter{Analisi}

\section{Requisiti}
L'applicazione è un gioco che presenta un personaggio controllato dal giocatore con la possibilità di muoversi nella mappa in 4 direzioni e di combattere contro dei nemici utilizzando magie elementali. I nemici sconfitti potrebbero rilasciare delle cure o dei potenziamenti che favoriscono il giocatore. Per concludere il gioco, il giocatore deve entrare in possesso di 4 cristalli che vengono consegnati una volta sconfitti i 4 boss del gioco che sono nemici più difficili da sconfiggere.
\subsection*{Requisiti funzionali}
\begin{itemize}
    \item Movimento del giocatore.
    \item Movimento dei nemici.
    \item Presenza di oggetti ottenibili dal giocatore (Cure, potenziamenti e cristalli).
    \item Terminazione del gioco una volta raccolti 4 cristalli o se il giocatore viene sconfitto.
    \item Posizionamento e distribuzione degli oggetti.
    \item Possibilità di fare battaglie tra giocatore e nemici.
    \item Nemici più forti (boss) che se sconfitti rilasciano i cristalli per terminare il gioco.
    \item Possibilità di utilizzo di magie in battaglia di diverso tipo (Fuoco, Acqua, Fulmine, Erba).
    \item Aumento di livello tramite guadagno di esperienza sconfiggendo i nemici.
\end{itemize}

\subsection*{Requisiti non funzionali}
\begin{itemize}
    \item Il gioco deve essere multipiattaforma.
    \item \textit{TODO}
\end{itemize}

\section{Analisi e modello del dominio}

All'inizio al giocatore viene chiesto di che tipo elementale sarà il personaggio da controllare, in base a questa scelta gli verrà quindi assegnata una mossa di base di quel tipo e avrà le mosse di quel tipo potenziate fino alla fine del gioco.\\
Il giocatore può muoversi di una cella alla volta in una mappa a griglia in 4 direzioni (Nord, Est, Sud, Ovest) e una battaglia con i nemici (anch'essi di un certo tipo elementale) inizia quando la cella in cui è il giocatore combacia con quella di un nemico.\\
Per affrontare un nemico in battaglia il giocatore ha a disposizione massimo 4 mosse (non per forza dello stesso tipo del giocatore). Il combattimento avviene a turni alternati, il primo è il giocatore, poi il nemico e così via finché uno dei due viene sconfitto, se è il giocatore, il gioco termina.\\
Allo sconfiggere dei nemici viene conferita al giocatore una certa quantità di esperienza che serve ad aumentare di livello e un oggetto casuale, l'oggetto viene salvato nell'inventario del giocatore e potrà essere di diverso tipo, es. oggetto curativo(ripristina un tot di vita), booster di statistiche(per esempio aumenta l'attacco di un certo tipo di mosse) ecc.. L'aumento di livello comporta un incremento generale delle statistiche ovvero attacco, difesa e vita di un valore costante. Ogni 5 livelli verrà presentata al giocatore la possibilità di imparare una nuova mossa di un tipo casuale, se il giocatore ha già 4 mosse potrà decidere di scambiare quella nuova con una di quelle che conosce già. All'aumentare di livello sarà richiesta sempre più esperienza per passare a quello successivo.\\
Ci sono diverse classi di nemico, alcuni più deboli e altri più forti, come i boss, che se sconfitti consegnano uno dei 4 oggetti necessari per concludere il gioco (i cristalli).\\

\subsection{Tipi elementali}
I seguenti sono i tipi elementali presenti, ognuno è efficace rispetto ad un altro, quindi quando vengono usate mosse di un certo tipo che risulta essere efficace rispetto al tipo di un nemico, si avranno dei moltiplicatori del danno. Lo stesso vale per i nemici che usano mosse di un tipo efficace rispetto a quello scelto dal giocatore all'inizio.
\\\\
Ad esempio, nel seguente schema si vede che Fulmine è efficace contro Acqua.


\begin{center}
\begin{tabular}{ c c c }
    Fulmine & $\rightarrow$ & Acqua \\
    Erba & $\rightarrow$ & Fulmine \\
    Acqua & $\rightarrow$ & Fuoco \\
    Fuoco & $\rightarrow$ & Erba \\
\end{tabular}
\end{center}

\subsection{UML}
\begin{figure}[H]
	\centering
	\input{the-exiled-uml.tex}
	\caption{Schema UML del dominio.} \label{fig:Schema UML del dominio.}
\end{figure}

\chapter{Design}

Qui entriamo nel dettaglio della struttura ad alto livello del gioco.

\section{Architettura}
\section{Design dettagliato}

\subsection*{Luca Casadei}

\subsection*{Francesco Pazzaglia}
La mia parte di progetto si concentrava sull'implementazione dettagliata del giocatore, comprendendo la definizione delle sue caratteristiche quali attributi(come la vita, l'esperienza, la relativa classe...) e le sue meccaniche in gioco. Quindi per facilitare la comunicazione tra il model del giocatore (\textit{Player}) e la view, ho introdotto un controller quindi, utilizzando il pattern \textit{MVC}.
Mi sono occupato della gestione del movimento del giocatore e delle altre entità (i nemici) all'interno della mappa di gioco. Pertanto, anche in questo caso è stato fatto uso di controller per consentire la visualizzazione dei nemici in movimento sulla mappa.
Infine, ho implementato la gestione delle condizioni di Game Over, che includevano la definizione delle regole e dei possibili eventi che portavano al termine del gioco, nonché la gestione delle rispettive schermate, come la chiusura del gioco o la possibilità di far ripartire una nuova partita.

\subsubsection{Player}
Nell'ambito del progetto del gioco, ho osservato una serie di caratteristiche comuni tra le diverse entità presenti nel gioco. Le caratteristiche di base del giocatore sono condivise anche dai vari nemici. 
Pertanto, in collaborazione con \textit{Luca Casadei}, responsabile della parte relativa ai nemici, abbiamo deciso di introdurre nel model un'interfaccia denominata \textit{GameCharacter}. Questa interfaccia contiene i metodi principali che definiscono le caratteristiche fondamentali comuni a tutte le entità nel gioco, come la vita, la posizione, il movimento e gli attributi.
In aggiunta all'interfaccia, è stata implementata la classe astratta \textit{GameCharacterImpl}, che concretizza l'interfaccia \textit{GameCharacter}. Questa classe è stata progettata in modo che il giocatore, e di conseguenza anche i nemici, possano estenderla e acquisire le caratteristiche comuni menzionate in precedenza. Questa architettura ci ha consentito di gestire in modo efficiente le proprietà condivise tra il giocatore e i nemici, garantendo una maggiore coerenza e facilità di estensione del codice senza ripetizioni.

Nella gestione del giocatore, ho introdotto un'interfaccia denominata \textit{Player}, che estende l'interfaccia preesistente \textit{GameCharacter}. Successivamente, ho realizzato l'implementazione di questa interfaccia attraverso una classe concreta chiamata \textit{PlayerImpl}. Tale procedura mi ha consentito di definire un comportamento specifico, mantenendo al contempo la flessibilità per estendere e personalizzare le funzionalità di base fornite dall'interfaccia \textit{GameCharacter}.

La struttura del modello è stata progettata seguendo il Composite Pattern. In particolare, si parte dall'interfaccia \textit{CharacterModel} con la relativa classe \textit{CharacterModelImpl} è stata configurata per contenere un elemento dell'interfaccia \textit{Player} e una collezione di nemici. Questa configurazione organizza la struttura del modello come un albero, dove \textit{CharacterModelImpl} funge da componente composito che contiene sia il giocatore che la collezione di nemici.

Nel contesto della View del videogioco in Java, sia il giocatore che i nemici sono stati gestiti attraverso una singola classe chiamata \textit{CharacterView}. Questa classe è stata progettata per utilizzare immagini al fine di rappresentare graficamente le entità del gioco. In particolare, sono state gestite delle animazioni mediante l'utilizzo di due immagini per ciascuna direzione (SU, GIÙ, DX e SX). Questo approccio è stato adottato per migliorare l'aspetto visivo del gioco e rendere più coinvolgente l'esperienza di gioco.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{PlayerUML.png}
	\caption{Schema UML del Model del Player e del GameCharacter}
	\label{fig:diagramma-classe-player}
\end{figure}

\subsubsection{Gestione del movimento}
Nell'ambito dell'implementazione del movimento delle entità all'interno della mappa di gioco, ho adottato due distinzioni principali. Per il movimento del giocatore, ho progettato un sistema basato sull'input dell'utente tramite la tastiera. D'altra parte, per i nemici, ho sviluppato un meccanismo autonomo di movimento. In pratica, i nemici si spostano all'interno di un'area definita dalla loro classe, e quando il giocatore si avvicina entro un determinato raggio, i nemici iniziano a inseguirlo. Questo comportamento è stato implementato attraverso due metodi: uno per calcolare la distanza tra il giocatore e un nemico (il metodo \textit{calculateDistance}), e un altro per determinare la direzione in cui il nemico deve muoversi per inseguire il giocatore (il metodo \textit{calculateChaseDirection}). Questo approccio consente un comportamento dinamico e coinvolgente per i nemici, rendendo il gioco più interessante e sfidante per il giocatore.
Considerando la decisione di non impiegare i thread nel nostro progetto, i nemici si sposteranno esclusivamente in risposta all'input dell'utente. Di conseguenza, i nemici si muoveranno solamente quando l'utente eseguirà uno spostamento sulla mappa di gioco.

In particolare, ho utilizzato il \textit{CharacterModel} per definire il comportamento del movimento sia per il personaggio che per i nemici. Successivamente, all'interno del \textit{CharacterController}, ho implementato un metodo di movimento che ha richiamato i metodi precedentemente definiti nel Model. Questa scelta è stata fatta per mantenere la separazione delle responsabilità e organizzare il movimento all'interno del pattern \textit{MVC}. Inoltre, nella classe \textit{GameKeyListener} della View, ho gestito l'input dell'utente associando i movimenti alle direzioni corrispondenti ai tasti premuti (ad esempio, W per su, S per giù, A per sinistra e D per destra)



\subsection*{Marco Magnani}

\subsection*{Manuel Baldoni}


\chapter{Sviluppo}

\section{Testing automatizzato}
\section{Note di sviluppo}

\subsection*{Luca Casadei}
\subsection*{Francesco Pazzaglia}
\subsection*{Marco Magnani}
\subsection*{Manuel Baldoni}

\chapter{Commenti finali}

\section{Autovalutazione e lavori futuri}
\section{Difficoltà incontrate e commenti per i docenti}

\appendix
\chapter{Guida utente}

\chapter{Esercitazioni di laboratorio}
Elenco dei Permalink delle consegne nel forum studenti del modulo di laboratorio.
\section*{Consegne}
\subsection{luca.casadei27@studio.unibo.it}
\begin{itemize}
	\item Laboratorio 06: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=146511#p208401}
	\item Laboratorio 07: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=147598#p209323}
	\item Laboratorio 08: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=148025#p209782}
	\item Laboratorio 09: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=149231#p211336}
	\item Laboratorio 10: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=150252#p212475}
\end{itemize}

\end{document}