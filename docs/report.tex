\documentclass[a4paper,12pt]{report}

\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{hyperref}
\usepackage{tikz}

% Questo commentalo se vuoi scrivere in inglese.
\usepackage[italian]{babel}

\usepackage[italian]{cleveref}

\title{Progetto di Programmazione ad Oggetti\\``The Exiled''}

\author{Luca Casadei, Francesco Pazzaglia, Marco Magnani, Manuel Baldoni}
\date{\today}


\begin{document}

\maketitle

\tableofcontents

\chapter{Analisi}

\section{Requisiti}
L'applicazione è un gioco che presenta un personaggio controllato dal giocatore con la possibilità di muoversi nella mappa in 4 direzioni e di combattere contro dei nemici utilizzando magie elementali. I nemici sconfitti potrebbero rilasciare delle cure o dei potenziamenti che favoriscono il giocatore. Per concludere il gioco, il giocatore deve entrare in possesso di 4 cristalli che vengono consegnati una volta sconfitti i 4 boss del gioco che sono nemici più difficili da sconfiggere.
\subsection*{Requisiti funzionali}
\begin{itemize}
    \item Movimento del giocatore.
    \item Movimento dei nemici.
    \item Presenza di oggetti ottenibili dal giocatore (Cure, potenziamenti e cristalli).
    \item Terminazione del gioco una volta raccolti 4 cristalli o se il giocatore viene sconfitto.
    \item Rilascio degli oggetti da parte dei nemici.
    \item Possibilità di fare battaglie tra giocatore e nemici.
    \item Nemici più forti (boss) che se sconfitti rilasciano i cristalli per terminare il gioco.
    \item Possibilità di utilizzo di magie in battaglia di diverso tipo (Fuoco, Acqua, Fulmine, Erba).
    \item Aumento di livello tramite guadagno di esperienza sconfiggendo i nemici.
\end{itemize}

\subsection*{Requisiti non funzionali}
\begin{itemize}
    \item Il gioco deve essere multipiattaforma.
    \item L'interfaccia deve essere ridimensionabile.
\end{itemize}

\section{Analisi e modello del dominio}

All'inizio al giocatore viene chiesto di che tipo elementale sarà il personaggio da controllare, in base a questa scelta gli verrà quindi assegnata una mossa di base di quel tipo e avrà le mosse di quel tipo potenziate fino alla fine del gioco.\\
Il giocatore può muoversi di una cella alla volta in una mappa a griglia in 4 direzioni (Nord, Est, Sud, Ovest) e una battaglia con i nemici (anch'essi di un certo tipo elementale) inizia quando la cella in cui è il giocatore combacia con quella di un nemico.\\
Per affrontare un nemico in battaglia il giocatore ha a disposizione massimo 4 mosse (non per forza dello stesso tipo del giocatore). Il combattimento avviene a turni alternati, il primo è il giocatore, poi il nemico e così via finché uno dei due viene sconfitto, se è il giocatore, il gioco termina.\\
Allo sconfiggere dei nemici viene conferita al giocatore una certa quantità di esperienza che serve ad aumentare di livello e un oggetto casuale, l'oggetto viene salvato nell'inventario del giocatore e potrà essere di diverso tipo, es. oggetto curativo(ripristina un tot di vita), booster di statistiche(per esempio aumenta l'attacco di un certo tipo di mosse) ecc.. L'aumento di livello comporta un incremento generale delle statistiche ovvero attacco, difesa e vita di un valore costante. Ogni 5 livelli verrà presentata al giocatore la possibilità di imparare una nuova mossa di un tipo casuale, se il giocatore ha già 4 mosse potrà decidere di scambiare quella nuova con una di quelle che conosce già. All'aumentare di livello sarà richiesta sempre più esperienza per passare a quello successivo.\\
Ci sono diverse classi di nemico, alcuni più deboli e altri più forti, come i boss, che se sconfitti consegnano uno dei 4 oggetti necessari per concludere il gioco (i cristalli).\\

\subsection{Tipi elementali}
I seguenti sono i tipi elementali presenti, ognuno è efficace rispetto ad un altro, quindi quando vengono usate mosse di un certo tipo che risulta essere efficace rispetto al tipo di un nemico, si avranno dei moltiplicatori del danno. Lo stesso vale per i nemici che usano mosse di un tipo efficace rispetto a quello scelto dal giocatore all'inizio.
\\\\
Ad esempio, nel seguente schema si vede che Fulmine è efficace contro Acqua.


\begin{center}
\begin{tabular}{ c c c }
    Fulmine & $\rightarrow$ & Acqua \\
    Erba & $\rightarrow$ & Fulmine \\
    Acqua & $\rightarrow$ & Fuoco \\
    Fuoco & $\rightarrow$ & Erba \\
\end{tabular}
\end{center}

\subsection{UML}
\begin{figure}[H]
	\centering
	\input{the-exiled-uml.tex}
	\caption{Schema UML del dominio.} \label{fig:Schema UML del dominio.}
\end{figure}

\chapter{Design}

Qui entriamo nel dettaglio della struttura ad alto livello del gioco.

\section{Architettura}
\subsection{Model entry point}
La struttura del progetto segue il modello MVC, questa divisione ha come entry point del model la classe \textit{GameModelImpl} che implementa \textit{GameModel}, essa ha il ruolo di dare accesso agli altri componenti del model, tra cui:
\begin{itemize}
	\item \textit{CharacterModel}: Model che gestisce il player, nemici e relativi attributi.
	\item \textit{CombatModel}: Fornisce la gestione del combattimento tra player e nemico.
	\item \textit{ItemsModel}: Fornisce la gestione degli item del gioco.
	\item \textit{MapModel}: Fornisce la gestione della mappa e le relative celle.
	\item \textit{MenuModel}: Fornisce la gestione interna del menu di gioco.
\end{itemize}
\subsection{Controller entry point}
A questo punto di accesso si collega il controller, che è composto anch'esso da un punto di accesso principale che è \textit{GameController}, questo fornisce accesso alle seguenti sottoparti del controller:
\begin{itemize}
	\item \textit{CharacterController}: Gestisce il collegamento tra view e model per movimento azioni compibili dalle entità del gioco (nemici e giocatore).
	\item \textit{CombatController}: Collega la view con il model per il combattimento.
	\item \textit{ItemsController}: Collega la view con il model per la gestione degli oggetti dell'inventario.
	\item \textit{MapController}: Collega la view con il model gestendo la mappa e le celle.
	\item \textit{MenuController}: Collega view e model per la gestione del menu di gioco.
\end{itemize}
\subsection{Relazione tra View e Controller}
La view viene suddivisa in diverse sottoparti come le precedenti componenti architetturali, l'entry point è la classe \textit{GameView} che è quella che fa partire il motore grafico del gioco. Le sottoparti sono:
\begin{itemize}
	\item \textit{CharacterView}: Visualizzazione dei nemici e del giocatore.
	\item \textit{CombatView}: Visualizzazione del combattimento tra un giocatore e un nemico.
	\item \textit{InventoryView}: Visualizzazione dell'inventario e uso degli item.
	\item \textit{PlayerClassView}: Visualizzazione iniziale per la scelta della classe del giocatore tra gli elementi disponibili.
	\item \textit{GameOverView}: Schermata di Game Over.
	\item \textit{GameVictoryView}: Schermata di vittoria del gioco.
	\item \textit{NewGameView}: Schermata di avvio.
\end{itemize}
Alcuni elementi grafici sono stati realizzati con apposite classi di view che hanno quindi un comportamento molto specifico e non comportano necessariamente un collegamento con il controller, ad esempio: \textit{HUDView}, \textit{GameGridView}, \textit{GameMoveChangeView}.

\subsection{Schema MVC}
\begin{figure}[H]
	\centering
	\input{exiled-architecture-uml.tex}
	\caption{Schema UML che rappresenta l'architettura MVC} 
	\label{fig:Schema UML che rappresenta l'architettura MVC}
\end{figure}

In conclusione, anche rimpiazzando totalmente il framework di Swing per la view con un altro (es. JavaFX) non è necessario fare alcun tipo di alterazione al controller e tantomeno al model.

\section{Design dettagliato}
\subsection*{Luca Casadei}
Personalmente mi sono occupato di parte della realizzazione delle mosse, della realizzazione di parte dell'entità \textit{GameCharacter}, della realizzazione dei nemici e della loro distribuzione sulla mappa in base al tipo, della creazione della mappa e relativa suddivisione in aree, della creazione ed assegnazione degli attributi dei \textit{GameCharacter}. Per ciascuno di questi elementi del model è stato realizzato un controller apposito per poter utilizzare il pattern MVC.
\subsubsection{Entità "Nemico"}
\textbf{Problema:} Definire il concetto di nemico e come omologarlo al giocatore per evitare ripetizioni di codice (DRY).
Questa difficoltà è riassumibile nel dover suddividere i nemici in comuni e boss finali, divisi ciascuno in base al proprio "tipo elementale" e con la propria quantità di esperienza rilasciata alla sconfitta. Ogni nemico deve inoltre avere un set di mosse personalizzato che varia anch'esso in base al tipo.\\
\textbf{Soluzione:} La soluzione adottata è stata quella di estendere un concetto di \textit{GameCharacter}, che contenesse tutte le informazioni e le azioni condivise tra giocatore e nemici, e successivamente effettuare la relativa divisione costruendo due interfacce diverse, una per il giocatore e una per il nemico. Per quest'ultimo è stata realizzata un'apposita interfaccia implementata da una classe astratta, che poi verrà utilizzata attraverso un pattern creazionale descritto successivamente per generare e distribuire i nemici sulla mappa. I nemici vengono infine divisi ulteriormente in generici e boss.
\subsubsection{UML dell'entità "Nemico"}
\begin{figure}[H]
	\centering
	\input{enemy/enemy-uml.tex}
	\caption{Schema UML che rappresenta la gestione dell'entità "Nemico"} 
	\label{fig:Schema UML dell'entità nemico}
\end{figure}
La classe \textit{EnemyImpl} contiene metodi astratti in modo tale da poter gestire la singola implementazione a seconda del diverso nemico del gioco, come spiegato successivamente.

\subsubsection{Creazione dei nemici}
\textbf{Problema}: Generare i nemici in modo scalabile (l'aggiunta di un nuovo nemico al gioco deve essere meno complesso e tedioso possibile).\\
\textbf{Soluzione:} Come introdotto precedentemente, il nemico è rappresentato da una classe astratta \textit{EnemyImpl} che viene sfruttata attraverso l'uso del pattern \href{https://refactoring.guru/design-patterns/factory-method}{\textit{Factory Method}}.
Ci sono diversi tipi di nemico nel gioco, quelli generici e i Boss. La classe che fa uso di questo pattern è \textit{EnemyFactory} e la relativa implementazione \textit{EnemyFactoryImpl}.\\ \textbf{Alternative:} Un'alternativa possibile era quella di creare una classe che ereditasse da \textit{EnemyImpl} per ogni nemico presente nel gioco ed assegnarli manualmente le mosse, l'esperienza rilasciata ecc..., in questo caso il codice sarebbe risultato meno scalabile e avrebbe reso l'aggiunta di nemici tediosa.\\
Segue uno schema UML che rappresenta il metodo generazionale dei nemici (Esclusa la divisione tra nemici generici e Boss che viene trattata separatamente in una sottosezione successiva).

\begin{figure}[H]
	\centering
	\input{enemy/enemyfactory-uml.tex}
	\caption{Schema UML della factory di nemici (Boss esclusi)}
	\label{fig:Schema UML della factory di nemici}
\end{figure}

\textbf{Problema:} Divisione dei boss dai nemici generici, per evitare che l'oggetto rilasciato al giocatore venga scelto casualmente.\\
\textbf{Soluzione:} In questo caso è stato necessario considerare i boss come una specializzazione di nemici generici, quindi come sottoclassi di \textit{EnemyImpl} ma con una loro classe specifica dedicata che consenta di scegliere manualmente il tipo di oggetto rilasciato alla sconfitta. Segue uno schema UML che aggiunge il concetto di nemico.

\begin{figure}[H]
	\centering
	\input{enemy/boss-enemy-uml.tex}
	\caption{Schema UML della gestione dei Boss.}
	\label{fig:Schema UML della gestione dei boss.}
\end{figure}

In maniera analoga nella "Factory" di nemici descritta precedentemente vengono utilizzate le classi dei boss per la loro generazione.

\subsubsection{Raggruppare i nemici in collezione}
\textbf{Problema:} Come raggruppare assieme tutti i nemici generati per poterli disporre sulla mappa?\\
\textbf{Soluzione:} In questo caso ho creato un'interfaccia apposita \textit{EnemyCollection} che segue il pattern \href{https://refactoring.guru/design-patterns/iterator}{Iterator} per poter scorrere tutti i nemici indipendentemente da come venga implementata la collezione. Segue uno schema UML della struttura.

\begin{figure}[H]
	\centering
	\input{enemy/enemycollection-uml.tex}
	\caption{Schema UML della collezione di nemici per gestire la mappa.}
	\label{fig:Schema UML della collezione di nemici per gestire la mappa.}
\end{figure}

\subsubsection{Piazzamento dei nemici sulla mappa : \textit{CharacterModel}}
\textbf{Problema:} Mettere in relazione la mappa e i nemici attraverso un'unico concetto nel model.\\
\textbf{Soluzione:} Effettuare lo scattering dei nemici durante la loro inizializzazione, al momento della creazione del model.
Una delle parti da me gestite è stata quella dell'inizializzazione dei nemici utilizzando le classi sopradescritte, e il loro posizionamento sulla mappa attraverso alcuni metodi all'interno dell'implementazione dell'interfaccia \textit{CharacterModel}.\\
In particolare, nella classe \textit{CharacterModelImpl} è contenuta la \textit{EnemyCollection} che servirà al controller per scorrere su ogni nemico presente, vi è anche un metodo di inizializzazione in cui si prende il numero di nemici da configurazione, e si generano tutti attraverso la \textit{EnemyFactory} e vengono man mano posizionati in celle (e aggiunti alla collezione) a patto che:
\begin{itemize}
	\item Non vengano posizionati in uno dei 4 vertici della mappa. (Lì ci sono i boss)
	\item Non vengano posizionati in una cella il cui tipo non corrisponde a quello del nemico.
	\item Non vengano posizionati in una cella in cui sia già presente un nemico o il giocatore (cella piena)
\end{itemize}
Una volta generati tutti i nemici generici, vengono creati i 4 boss sempre attraverso la factory e vengono aggiunti anch'essi alla \textit{EnemyCollection} perché si tratta sempre di nemici e vengono spostati manualmente ai quattro vertici della mappa, attraverso un apposito metodo che dato il tipo di cella ne ricava l'angolo della mappa (Spiegato nella prossima sezione relativa alla mappa).

\subsubsection{Mappa di gioco nel \textit{Model}}
\textbf{Problema:} Come gestire la mappa di gioco a livello di divisione delle celle? Come dare un certo tipo ad ogni cella?

\subsection*{Francesco Pazzaglia}
La mia parte di progetto si concentra sull'implementazione dettagliata del giocatore, comprendendo la definizione delle sue caratteristiche quali attributi(la vita, l'esperienza, la relativa classe...) e le sue meccaniche in gioco. Per facilitare la comunicazione tra il Model del giocatore (\textit{Player}) e la View è stato introdotto un Controller garantendo l'utilizzo del pattern \textit{MVC}.

Mi sono anche occupato della gestione del movimento del giocatore e delle altre entità (i nemici) all'interno della mappa di gioco. Pertanto, anche in questo caso è stato fatto uso di Controller per consentire la visualizzazione dei nemici in movimento sulla mappa.

Infine, ho implementato la gestione delle condizioni di chiusura del gioco(vittoria e game over), che includevano la definizione delle regole e dei possibili eventi che portavano al termine del gioco, nonché la gestione delle rispettive schermate, come la chiusura del gioco o la possibilità di riavviare una nuova partita.

\subsubsection{Player}
Nella parte del giocatore, il problema principale consisteva nell'identificare e gestire in modo efficiente le caratteristiche comuni con i nemici, al fine di evitare ripetizioni e mantenere il codice conciso. 
Pertanto, in collaborazione con \textit{Luca Casadei}, responsabile della parte relativa ai nemici, abbiamo deciso di introdurre nel Model un'interfaccia denominata \textit{GameCharacter}. Questa interfaccia contiene i metodi principali che definiscono le caratteristiche fondamentali comuni a tutte le entità nel gioco, come la vita, la posizione, il movimento e gli attributi.
In aggiunta all'interfaccia, è stata implementata la classe astratta \textit{GameCharacterImpl}, che concretizza l'interfaccia \textit{GameCharacter}. Questa classe è stata progettata in modo che il giocatore, possa estenderla e acquisire le caratteristiche comuni menzionate in precedenza. Questa architettura ci ha consentito di gestire in modo efficiente le proprietà condivise tra il giocatore e i nemici, garantendo una maggiore coerenza e facilità di estensione del codice senza ripetizioni.

Per la gestione del giocatore, ho introdotto un'interfaccia denominata \textit{Player}, che estende l'interfaccia preesistente \textit{GameCharacter}. Successivamente, ho realizzato l'implementazione di questa interfaccia attraverso una classe concreta chiamata \textit{PlayerImpl}. Tale procedura mi ha consentito di definire un comportamento specifico, mantenendo al contempo la flessibilità per estendere e personalizzare le funzionalità di base fornite dall'interfaccia \textit{GameCharacter}.

\begin{figure}[H]
	\centering
	\input{player/the-exiled-player-uml.tex}
	\caption{Schema UML del Model del Player e del GameCharacter}
	\label{fig:the-exiled-player-uml}
\end{figure}

Nella parte inerente alla View sia il giocatore che i nemici sono stati gestiti attraverso una classe chiamata \textit{CharacterView}. Questa classe è stata progettata per utilizzare immagini al fine di rappresentare graficamente le entità del gioco. In particolare, sono state gestite delle animazioni mediante l'utilizzo di due immagini per ciascuna direzione (NORD, SUD, EST e OVEST). Questo approccio è stato adottato per migliorare l'aspetto visivo del gioco e rendere più coinvolgente l'esperienza di gioco. 

La \textit{CharacterView} è una estensione di \textit{JLabel} che gestisce l'aspetto visivo dei personaggi nel gioco. All'interno di questa classe, viene impostata l'immagine che la \textit{JLabel} deve rappresentare, selezionata tra quelle disponibili nelle risorse del gioco. Inizialmente, per il player, viene scelta un'immagine in base alla sua classe, e lo stesso principio si applica ai nemici. Questa classe ausiliaria ci ha permesso di garantire una gestione ottimale della scalabilità della griglia di gioco durante il ridimensionamento della finestra e ci ha permesso inoltre effettuare efficacemente il cambio di immagine per le animazioni.

Per garantire la comunicazione tra il Model e la View del \textit{Player} è stato introdotto un Controller, sotto forma di interfaccia, denominato \textit{CharacterController}. La relativa classe di implementazione invece è stata chiamata \textit{CharacterControllerImpl} dove, al suo interno sono stati definiti i metodi per il controllo del \textit{Player}, tra cui quelli relativi al movimento, all'assegnamento della classe(del tipo), all'uso di modificatori di esperienza e di livello, nonché i relativi metodi Getter necessari per l'interfaccia grafica.

Nel \textit{CharacterController} sono stati definiti metodi generali applicabili a qualsiasi entità presente nel gioco, sia un giocatore o nemico. Per tale motivo, è stata introdotta un'ulteriore interfaccia denominata \textit{CharacterModel}, accompagnata dalla relativa classe \textit{CharacterModelImpl}. Questa struttura consente al controller di gestire entrambe le tipologie di entità in modo uniforme e coerente.

Il design pattern che viene utilizzato per gestire la parte del \textit{Player} è Template Method. Questo pattern consente di definire uno scheletro di comportamento comune per il \textit{Player}. La classe astratta \textit{GameCharacterImpl} costituisce la base per tutte le entità di gioco, ad esempio definisce il metodo \textit{move(Position)}, ossia la struttura generica per il movimento di un'entità. L'interfaccia \textit{Player}, che estende \textit{GameCharacter}, definisce ulteriori metodi specifici del giocatore per il livello, l'esperienza, l'inventario ecc. La classe \textit{PlayerImpl} implementa l'interfaccia \textit{Player} e fornisce le implementazioni specifiche dei metodi definiti nell'interfaccia. Questo approccio favorisce la riutilizzabilità del codice e facilita l'estensione delle funzionalità del \textit{Player} senza dover modificare la struttura di base definita nella classe astratta \textit{GameCharacterImpl}.

\subsubsection{Gestione del movimento}
Nella gestione del movimento, il problema principale è stato comprendere come distinguere il movimento del giocatore da quello dei nemici sulla mappa di gioco. Inoltre, la scelta di utilizzare l'input da tastiera o da mouse ha generato incertezze riguardo alla gestione della griglia relativa alla mappa.

In merito a quanto detto, per l'implementazione del movimento delle entità all'interno della mappa di gioco, ho adottato due distinzioni principali. Per il movimento del giocatore ho progettato un sistema basato sull'input dell'utente tramite tastiera. D'altra parte, per i nemici, ho sviluppato un meccanismo autonomo di movimento. In pratica, i nemici si spostano in maniera pseudo-casuale all'interno di un'area definita dalla loro tipologia(Fire, Bolt, Water e Grass) e qualora il giocatore si dovesse avvicinare, entro un certo raggio, ad un nemico, quest'ultimo inizierà a inseguirlo per combattere. Questo comportamento è stato realizzato attraverso due metodi: uno per calcolare la distanza tra il giocatore e un nemico (il metodo privato \textit{calculateDistance}), e un altro per determinare la direzione in cui il nemico deve muoversi per inseguire il giocatore (il metodo privato \textit{calculateChaseDirection}). Questo approccio consente un comportamento dinamico e coinvolgente per i nemici, rendendo il gioco più interessante e stimolante per il giocatore, dato che per poter completare il gioco bisogna sconfiggere i quattro Boss che sono situati agli estremi della mappa di gioco.
Considerando la decisione di non impiegare i thread nel nostro progetto, i nemici si sposteranno esclusivamente in risposta all'input dell'utente. Di conseguenza, i nemici si muoveranno solamente quando l'utente eseguirà uno spostamento nella mappa.

In particolare, ho utilizzato il \textit{CharacterModel} per definire il meccanismo di movimento sia per il personaggio che per i nemici. Successivamente, all'interno del \textit{CharacterController}, ho implementato un metodo di movimento che ha richiamato le funzioni precedentemente definite nel Model. Questa scelta è stata fatta per mantenere la separazione delle responsabilità e per organizzare il movimento applicando il pattern \textit{MVC}. Inoltre, nella classe \textit{GameKeyListener} della View, ho gestito l'input dell'utente associando i movimenti alle direzioni corrispondenti ai tasti premuti (ad esempio, W per su, S per giù, A per sinistra e D per	destra). La \textit{GameView} rappresenta la schermata principale dov'è inserita la mappa e l'HUD che visualizza gli attributi principali del personaggio.
Quando l'utente preme un tasto specifico sulla tastiera tra quelli elencati prima, all'interno della \textit{GameView}, il \textit{CharacterView} associato al giocatore si sposterà in una cella corrispondente. Di conseguenza, come precedentemente descritto, tutti i nemici, a meno che non siano vicini al giocatore, si sposteranno anch'essi, in una direzione scelta in modo pseudo-casuale.

\begin{figure}[H]
	\centering
	\include{movement/the-exiled-movement-uml.tex}
	\caption{Schema UML inerente al meccanismo di movimento}
	\label{fig:the-exiled-movement-uml}
\end{figure}

Oltre ai KeyListener di base per il movimento del giocatore, ho integrato la funzionalità che permette di utilizzare il tasto E per aprire l'inventario quando si è in gioco e il tasto ESC per aprire/chiudere il menu di gioco. Questa scelta è stata fatta per migliorare l'esperienza di gioco e rendere l'interfaccia più intuitiva e user-friendly, consentendo ai giocatori di navigare facilmente tra le diverse funzionalità senza interruzioni.

Avendo separato la gestione del movimento e dell'ascolto dei \textit{KeyListener} in una classe dedicata, è stato adottato il design pattern Observer. Questo pattern ha consentito di definire un meccanismo di notifica personalizzato attraverso la classe \textit{GameKeyListener}, che funge da Observer. \textit{GameKeyListener} implementa l'interfaccia \textit{KeyListener} e si occupa di ricevere notifiche sugli eventi di pressione dei tasti. In questo modo, sono stato in grado di gestire dinamicamente il movimento delle entità di gioco in risposta all'input dell'utente.

\subsubsection{Meccanismo di fine gioco}
Mi sono occupato di gestire la conclusione del gioco attraverso due scenari distinti: la vittoria(tramite la \textit{GameVictoryView}) e la sconfitta(tramite \textit{GameOverView}).

Nella parte della sconfitta ho realizzato la gestione del game over attraverso il \textit{GameController}. Utilizzando il metodo \textit{isOver()}, viene deciso quando il gioco è terminato e di conseguenza quando deve essere visualizzata la \textit{GameOverView} dedicata. Avendo un unico metodo per determinare il game over, ho potuto facilmente definire il suo criterio. Essendo un gioco centrato su un singolo giocatore principale, è stato naturale impostare il game over nel caso in cui la sua vita dovesse azzerarsi o scendere sotto lo zero, a seguito di un combattimento con un nemico. 

Lo stesso principio si applica alla GameVictoryView, la quale rappresenta la schermata che compare quando il gioco è completato con successo. Questa View viene attivata quando il metodo \textit{isWon()} restituisce un valore che indica se il giocatore ha vinto il gioco. Per poter vincere il gioco, il personaggio deve avere nel suo inventario i quattro cristalli della redenzione ottenuti sconfiggendo i Boss finali.\\

All'interno delle due schermate, sono stati inclusi due \textit{JButton} con relativi \textit{ActionListener}: uno permette di iniziare una nuova partita e l'altro serve per chiudere definitivamente il gioco.

La \textit{GameOverView} e la \textit{GameVictoryView} sono state integrate all'interno della \textit{GameView}, la schermata principale definita in precedenza. All'interno della sua classe è contenuto il campo del \textit{GameController}, che facilita il collegamento tra il Model e la View stessa. Grazie a questo Controller, è possibile determinare quando la schermata principale deve essere sostituita dalla schermate di vincita o perdita del gioco.

Questo approccio ha semplificato la gestione delle schermate di fine gioco, utilizzando una logica chiara e intuitiva nella scrittura del codice.

\begin{figure}[H]
	\centering
	\include{victory_gameover/the-exiled-victory_gameover-uml.tex}
	\caption{Schema UML del GameOver con relativa vista sulle View}
	\label{fig:the-exiled-victory_gameover-uml}
\end{figure}

Il design pattern applicato alla parte di \textit{GameOverView} e \textit{GameVictoryView}, è il pattern comportamentale Strategy. Le due View rappresentano due strategie diverse per gestire la visualizzazione dell'esito del gioco (game over o vittoria). La classe \textit{GameView} utilizza queste strategie decidendo quale delle due visualizzare in base alle condizioni definite nei metodi \textit{isOver()} e \textit{isWon()} del \textit{GameController}. Utilizzando lo Strategy Pattern, è possibile cambiare dinamicamente il comportamento di \textit{GameView} sostituendo una strategia con un'altra senza modificare il suo codice.

\subsection*{Marco Magnani}
La parti del progetto in cui ho impiegato la maggior parte del tempo sono l'inventario del player, gli oggetti da cui esso è composto, la hud e la logica per l'aumento di livello del player.

\subsubsection{Item e Inventory}

Per implementare la gestione delle entità degli oggetti, ho adottato un approccio di astrazione mirato a massimizzare la riutilizzabilità del codice e a eliminare duplicazioni non necessarie. Nel contesto del gioco, gli oggetti possono essere categorizzati in tre tipologie distinte: curativi, di potenziamento e risorse (ad esempio, cristalli).
L'obiettivo era creare un sistema in cui l'inventario potesse accogliere tutti questi tipi di oggetti diversi, trattandoli però uniformemente come se appartenessero tutti alla stessa categoria.
\begin{figure}[H]
	\centering
	\input{item/the-exiled-item-uml.tex}
	\caption{Schema UML del Model degli Item e dell'Inventory}
	\label{fig:the-exiled-item-uml}
\end{figure}

La struttura che ho concepito prevede che tutti gli oggetti estendano un'interfaccia astratta, garantendo uniformità nei campi essenziali. Un ostacolo che ho affrontato riguardava la suddivisione tra oggetti curativi e di potenziamento, poiché entrambi possono essere utilizzati nel gioco, ma la logica di implementazione per i due utilizzi è differente.

Per superare questa sfida, ho introdotto l'interfaccia \textit{UsableItem}, seguendo il design pattern \textit{Template Method}. Questa interfaccia consente ad entrambe le categorie di implementare la propria logica di utilizzo, differenziandosi attraverso il metodo \textit{"use()"}.

L'astrazione fornita da UsableItem aiuta anche per la visualizzazione dell'inventario, in quanto consente di rendere cliccabili solo gli oggetti effettivamente utilizzabili.

\begin{figure}[H]
	\centering
	\input{item/the-exiled-itemFactory_itemContainer-uml.tex}
	\caption{Schema UML della ItemFactory e dell'ItemContainer}
	\label{fig:the-exiled-itemFactory_itemContainer-uml}
\end{figure}

Per risolvere un altro problema legato alla creazione degli oggetti, ho voluto garantire che qualsiasi classe che necessiti di creare un oggetto non dovesse conoscere la logica specifica di creazione. A questo scopo, ho implementato una Factory utilizzando il design pattern \textit{Factory} per la creazione degli item. Questa Factory viene utilizzata dall'Item Container per gestire la creazione di tutti gli oggetti di gioco. L'enum \textit{ItemNames} è stato introdotto per contenere i nomi di tutti gli oggetti del gioco, svolgendo il ruolo di "chiavi" per identificare gli item.

\begin{figure}[H]
	\centering
	\input{item/the-exiled-inventory-uml.tex}
	\caption{Schema UML dell'inventario}
	\label{fig:the-exiled-inventory-uml}
\end{figure}

Gli oggetti sono tutti generalizzati attraverso l'interfaccia Item, semplificando notevolmente la gestione, specialmente all'interno dell'inventario. Per la View dell'inventario, ho adottato il pattern \textit{Strategy}, in particolare mediante l'interfaccia \textit{ItemController} e la sua implementazione, \textit{ItemControllerImpl}. Quest'ultima è responsabile dell'effettiva logica di gestione degli oggetti nel gioco e interagisce con il modello degli item per gestire l'inventario.

L'utilizzo di questo pattern è stato pensato per rendere il progetto aperto a future estensioni. Se si dovesse aggiungere un'altra visualizzazione degli oggetti, sarebbe possibile creare un'altra implementazione dell'interfaccia ItemController, utilizzando una logica specifica per la gestione degli oggetti in quella particolare vista.
\subsubsection{Hud}
\begin{figure}[H]
	\centering
	\input{hud/the-exiled-hud-uml.tex}
	\caption{Schema UML della HUD}
	\label{fig:the-exiled-hud-uml}
\end{figure}

Passando all'HUD (head-up display), quest'ultimo mostra le informazioni di base del giocatore sia sulla pagina principale che durante gli scontri con i nemici. Queste informazioni includono la vita, il livello, la classe e l'esperienza del giocatore. Ho gestito l'HUD come una classe di visualizzazione separata e indipendente, la quale può essere resa visibile e aggiornata quando necessario.

Dal momento che l'HUD è sempre visibile, anche durante i combattimenti, una problematica è stata quella di mantenere costantemente aggiornate le statistiche del giocatore in base ai suoi cambiamenti di stato, come la diminuzione della vita o l'aumento di livello. Per risolvere questo problema, ho optato per un'implementazione simile ad un \textit{Observer}. Ogni volta che il modello del giocatore subisce una modifica, ad esempio quando la vita diminuisce, l'HUD viene notificato attraverso il metodo initialize dei cambiamenti, consentendogli di aggiornare la visualizzazione dell'HUD di conseguenza.
\subsubsection{Levelling}
Infine, ho gestito il processo di aumento di livello del giocatore, che coinvolge la logica di incremento del livello raggiungendo una certa quantità di esperienza. Ho implementato anche il calcolo dell'esperienza necessaria per il prossimo livello, l'aumento delle statistiche ad ogni livello e la logica secondo cui il giocatore apprende nuove mosse ad intervalli specifici.
Per quanto riguarda l'aumento delle statistiche ad ogni incremento di livello, ho scelto di utilizzare un approccio randomizzato al fine di rendere il gioco meno monotono.

Per la logica delle nuove mosse apprese, ho adottato uno schema specifico: il giocatore di base apprende mosse della sua classe (ad esempio, mosse di tipo acqua se la classe è acqua). Se il giocatore conosce già tutte le mosse di quel tipo, imparerà casualmente una mossa di qualsiasi tipo. Questa scelta è stata fatta per rendere la gestione delle mosse più scalabile, in considerazione della possibilità di creare nuovi tipi elementali. Ad esempio, se venisse introdotto un tipo con una singola mossa, il giocatore comunque apprenderebbe nuove mosse.

\subsection*{Manuel Baldoni}


\chapter{Sviluppo}

\section{Testing automatizzato}
\section{Note di sviluppo}

\subsection*{Luca Casadei}
\begin{itemize}
	\item \textbf{Espressioni Lambda} e \textbf{Optional}: Utilizzati nella classe \textit{CharacterModel} nel metodo \textit{isCellEmpty} per verificare se una cella della mappa contiene qualcuno.\\
	\url{https://github.com/luca-casadei/the-exiled/blob/9a97a74beb0dd351cf5b1f72e6dd4cbeed1acc43/src/main/java/unibo/exiled/model/character/CharacterModelImpl.java#L99-L100}
	\item \textbf{Record}: Gli attributi sono gestiti come dei \textit{Java Records}, in particolare \textit{AdditiveAttributeImpl} e \textit{MultiplierAttributeImpl}.\\
	\url{https://github.com/luca-casadei/the-exiled/blob/9a97a74beb0dd351cf5b1f72e6dd4cbeed1acc43/src/main/java/unibo/exiled/model/character/attributes/AdditiveAttributeImpl.java#L8}
	\item \textbf{Libreria Mockito}: Usata per alcuni tests di JUnit, in particolare il test della classe \textit{CharacterControllerImpl}. Il permalink è relativo ad una piccola parte del codice dove viene usata questa libreria.\\
	\url{https://github.com/luca-casadei/the-exiled/blob/506d8a5ed7be7028e52f6b9613cb84fc03198110/src/test/java/unibo/exiled/controller/TestCharacterControllerImpl.java#L49}
\end{itemize}

\subsection*{Francesco Pazzaglia}

\begin{itemize}
	\item \textbf{Espressioni Lambda}: Utilizzate nei bottoni che hanno \textit{ActionListener} nella \textit{GameOverView}.
	\item \textbf{Optional}: Utilizzati per sostituire i \textit{null value}, usati nel \textit{CharacterModel}(metodo \textit{getPlayer()}) e anche per il passaggio della \textit{GameView} tra la differenti viste.
	\item \textbf{Stream}: Utilizzati nei Controller per controllare che il \textit{Player} abbia vinto il gioco.
\end{itemize}

\subsection*{Marco Magnani}
\begin{itemize}
	\item \textbf{Stream e Optional}: Utilizzati sia nell' \textit{ItemContainer} che nelle \textit{Moves} per ricavare esempio un item in base al tipo.\\ \url{https://github.com/luca-casadei/the-exiled/blob/71356cacbbef08c33f96d68802a33514823d3571/src/main/java/unibo/exiled/model/item/utilities/ItemsContainer.java#L76C7-L76C8}
	\item \textbf{Stream}: In \textit{CharacterModelImpl} utilizzato per evitare la compenetrazione di enemy all'interno della mappa, aggiunto nel commit con hash: f25b577fb319fbbcb38154b3f2b8a3233d5c561b\\
	\url{https://github.com/luca-casadei/the-exiled/blob/71356cacbbef08c33f96d68802a33514823d3571/src/main/java/unibo/exiled/model/character/CharacterModelImpl.java#L159C1-L160C1} 
	\item \textbf{Optional}: In \textit{ElementalType} e \textit{ItemNames} il metodo per prendere le relative immagini ritorna un Optional per gestire il caso in cui la mossa non sia presente nel progetto\\
	\url{https://github.com/luca-casadei/the-exiled/blob/71356cacbbef08c33f96d68802a33514823d3571/src/main/java/unibo/exiled/model/item/utilities/ItemNames.java#L83C1-L84C55}
	\item \textbf{Stream}: Nella \textit{ItemsModel} utilizzata per la conversione da \textit{Map\textless Item,Integer\textgreater} a \textit{Map\textless String,Integer\textgreater} ed anche per filtrare gli oggetti in base al nome, aggiunto nel GameModel commit con hash: 2e72b6911f473bfa3ee8685cd61f14ae8922f936\\
	\url{https://github.com/luca-casadei/the-exiled/blob/71356cacbbef08c33f96d68802a33514823d3571/src/main/java/unibo/exiled/model/item/ItemsModelImpl.java#L28C1-L28C90}
\end{itemize}


\subsection*{Manuel Baldoni}

\chapter{Commenti finali}

\section{Autovalutazione e lavori futuri}

\subsection*{Luca Casadei}
Personalmente ritengo che il mio contributo all'interno del team di sviluppo sia stato importante, sia per la parte realizzativa che per quella decisionale, ma non più importante di quella degli altri componenti del gruppo, con i quali è stato possibile lo confrontare le proprie idee di realizzazione, la corretta suddivisione dei compiti e uno sviluppo continuativo dell'applicazione anche se non necessariamente tutti presenti allo stesso momento o nello stesso luogo. Anche il caricamento del codice in parallelo con sistemi di controllo della versione è avvenuto in maniera secondo me pulita, perché tutti sono stati in grado di adottare questi strumenti in modo efficace senza creare troppi intoppi. Siccome la progettazione finale del progetto secondo me risulta abbastanza scalabile, non è esclusa l'ipotesi di arricchire ulteriormente il contenuto del gioco e le sue componenti, anche prendendo in forte considerazione la valutazione dei docenti.

\subsection*{Francesco Pazzaglia}

Nonostante le parti complesse del progetto e il fatto di sviluppare un progetto in team mi avesse inizialmente intimorito, sono soddisfatto di come siamo riusciti a completare e consegnare il gioco. Di solito sono abituato a lavorare da solo, ma ho trovato la collaborazione in team piuttosto soddisfacente. Lo scambio di idee e il confronto ci hanno aiutato a coordinarci efficacemente, individuando i metodi e le classi necessarie per varie parti del progetto. Lavorare in team è stato molto formativo e mi ha permesso di apprezzare come si possa realizzare un progetto insieme, nonostante stili di programmazione talvolta diversi.

\subsection*{Marco Magnani}
Il progetto è stato svolto con colleghi con cui ho avuto modo di collaborare già in precedenza alle superiori, quindi sapevo già prima cosa aspettarmi. La centralità della collaborazione e della discussione di idee è stata una costante durante lo sviluppo di questo progetto. Nel complesso, ritengo che il nostro lavoro sia stato soddisfacente, e in particolare, credo di aver gestito una buona parte del progetto sfruttando le competenze acquisite durante le lezioni.
\subsection*{Manuel Baldoni}

\section{Difficoltà incontrate e commenti per i docenti}

\appendix
\chapter{Guida utente}
Per la maggior parte delle azioni compibili nel gioco sono presenti bottoni sull'interfaccia, non è quindi necessario conoscere nessun particolare comando. Ne sono stati aggiunti alcuni aggiuntivi nell'inventario per l'apertura e la chiusura, come sottodescritto.
\section{Movimento}
Per muoversi sulla mappa a celle si usano i comandi:
\begin{itemize}
	\item \textit{W} per andare su.
	\item \textit{S} per andare giù.
	\item \textit{A} per andare a sinistra.
	\item \textit{D} per andare a destra.
\end{itemize}
\section{Inventario}
Si può aprire l'inventario con \textit{E} e richiuderlo con \textit{ESC}

\chapter{Esercitazioni di laboratorio}
Elenco dei Permalink delle consegne nel forum studenti del modulo di laboratorio.
\section*{Consegne}
\subsection{luca.casadei27@studio.unibo.it}
\begin{itemize}
	\item Laboratorio 06: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=146511#p208401}
	\item Laboratorio 07: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=147598#p209323}
	\item Laboratorio 08: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=148025#p209782}
	\item Laboratorio 09: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=149231#p211336}
	\item Laboratorio 10: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=150252#p212475}
\end{itemize}

\end{document}