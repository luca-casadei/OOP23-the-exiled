\documentclass[a4paper,12pt]{report}

\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{hyperref}
\usepackage{tikz}

% Questo commentalo se vuoi scrivere in inglese.
\usepackage[italian]{babel}

\usepackage[italian]{cleveref}

\title{Progetto di Programmazione ad Oggetti\\``The Exiled''}

\author{Luca Casadei, Francesco Pazzaglia, Marco Magnani, Manuel Baldoni}
\date{\today}


\begin{document}

\maketitle

\tableofcontents

\chapter{Analisi}

\section{Requisiti}
L'applicazione è un gioco che presenta un personaggio controllato dal giocatore con la possibilità di muoversi nella mappa in 4 direzioni e di combattere contro dei nemici utilizzando magie elementali. I nemici sconfitti potrebbero rilasciare delle cure o dei potenziamenti che favoriscono il giocatore. Per concludere il gioco, il giocatore deve entrare in possesso di 4 cristalli che vengono consegnati una volta sconfitti i 4 boss del gioco che sono nemici più difficili da sconfiggere.
\subsection*{Requisiti funzionali}
\begin{itemize}
    \item Movimento del giocatore.
    \item Movimento dei nemici.
    \item Presenza di oggetti ottenibili dal giocatore (Cure, potenziamenti e cristalli).
    \item Terminazione del gioco una volta raccolti 4 cristalli o se il giocatore viene sconfitto.
    \item Posizionamento e distribuzione degli oggetti.
    \item Possibilità di fare battaglie tra giocatore e nemici.
    \item Nemici più forti (boss) che se sconfitti rilasciano i cristalli per terminare il gioco.
    \item Possibilità di utilizzo di magie in battaglia di diverso tipo (Fuoco, Acqua, Fulmine, Erba).
    \item Aumento di livello tramite guadagno di esperienza sconfiggendo i nemici.
\end{itemize}

\subsection*{Requisiti non funzionali}
\begin{itemize}
    \item Il gioco deve essere multipiattaforma.
    \item \textit{TODO}
\end{itemize}

\section{Analisi e modello del dominio}

All'inizio al giocatore viene chiesto di che tipo elementale sarà il personaggio da controllare, in base a questa scelta gli verrà quindi assegnata una mossa di base di quel tipo e avrà le mosse di quel tipo potenziate fino alla fine del gioco.\\
Il giocatore può muoversi di una cella alla volta in una mappa a griglia in 4 direzioni (Nord, Est, Sud, Ovest) e una battaglia con i nemici (anch'essi di un certo tipo elementale) inizia quando la cella in cui è il giocatore combacia con quella di un nemico.\\
Per affrontare un nemico in battaglia il giocatore ha a disposizione massimo 4 mosse (non per forza dello stesso tipo del giocatore). Il combattimento avviene a turni alternati, il primo è il giocatore, poi il nemico e così via finché uno dei due viene sconfitto, se è il giocatore, il gioco termina.\\
Allo sconfiggere dei nemici viene conferita al giocatore una certa quantità di esperienza che serve ad aumentare di livello e un oggetto casuale, l'oggetto viene salvato nell'inventario del giocatore e potrà essere di diverso tipo, es. oggetto curativo(ripristina un tot di vita), booster di statistiche(per esempio aumenta l'attacco di un certo tipo di mosse) ecc.. L'aumento di livello comporta un incremento generale delle statistiche ovvero attacco, difesa e vita di un valore costante. Ogni 5 livelli verrà presentata al giocatore la possibilità di imparare una nuova mossa di un tipo casuale, se il giocatore ha già 4 mosse potrà decidere di scambiare quella nuova con una di quelle che conosce già. All'aumentare di livello sarà richiesta sempre più esperienza per passare a quello successivo.\\
Ci sono diverse classi di nemico, alcuni più deboli e altri più forti, come i boss, che se sconfitti consegnano uno dei 4 oggetti necessari per concludere il gioco (i cristalli).\\

\subsection{Tipi elementali}
I seguenti sono i tipi elementali presenti, ognuno è efficace rispetto ad un altro, quindi quando vengono usate mosse di un certo tipo che risulta essere efficace rispetto al tipo di un nemico, si avranno dei moltiplicatori del danno. Lo stesso vale per i nemici che usano mosse di un tipo efficace rispetto a quello scelto dal giocatore all'inizio.
\\\\
Ad esempio, nel seguente schema si vede che Fulmine è efficace contro Acqua.


\begin{center}
\begin{tabular}{ c c c }
    Fulmine & $\rightarrow$ & Acqua \\
    Erba & $\rightarrow$ & Fulmine \\
    Acqua & $\rightarrow$ & Fuoco \\
    Fuoco & $\rightarrow$ & Erba \\
\end{tabular}
\end{center}

\subsection{UML}
\begin{figure}[H]
	\centering
	\input{the-exiled-uml.tex}
	\caption{Schema UML del dominio.} \label{fig:Schema UML del dominio.}
\end{figure}

\chapter{Design}

Qui entriamo nel dettaglio della struttura ad alto livello del gioco.

\section{Architettura}

\section{Design dettagliato}
\subsection*{Luca Casadei}
Personalmente mi sono occupato di parte della realizzazione delle mosse, della realizzazione di parte dell'entità \textit{GameCharacter}, della realizzazione dei nemici e della loro distribuzione sulla mappa in base al tipo, della creazione della mappa e relativa suddivisione in aree, della creazione ed assegnazione degli attributi dei \textit{GameCharacter}. Per ciascuno di questi elementi del model è stato realizzato un controller apposito per poter utilizzare il pattern MVC.
\subsubsection{Entità "Nemico"}
La difficoltà nella realizzazione del concetto di nemico consiste nella suddivisione dei nemici in comuni e boss finali, divisi ciascuno in base al proprio tipo elementale e con la propria quantità di esperienza rilasciata alla sconfitta.\\
La soluzione adottata è stata quella di estendere un concetto di \textit{GameCharacter}, che contenesse tutte le informazioni e le azioni condivise tra giocatore e nemici, e successivamente effettuare la relativa divisione costruendo due interfacce diverse, una per il giocatore e una per il nemico. Per quest'ultimo è stata realizzata un'apposita interfaccia implementata da una classe astratta, che poi verrà utilizzata nell'istanziamento e la distribuzione dei nemici su mappa. Quest'ultima però viene spiegata nella sottosezione successiva.\\
\subsubsection{UML dell'entità "Nemico"}
\begin{figure}[H]
	\centering
	\input{enemy/enemy-uml.tex}
	\caption{Schema UML che rappresenta la gestione dell'entità "Nemico"} 
	\label{fig:Schema UML dell'entità nemico}
\end{figure}
La classe \textit{EnemyImpl} contiene metodi astratti in modo tale da poter gestire la singola implementazione a seconda del diverso nemico del gioco, come spiegato successivamente.

\subsection*{Francesco Pazzaglia}
La mia parte di progetto si concentra sull'implementazione dettagliata del giocatore, comprendendo la definizione delle sue caratteristiche quali attributi(la vita, l'esperienza, la relativa classe...) e le sue meccaniche in gioco. Per facilitare la comunicazione tra il Model del giocatore (\textit{Player}) e la View è stato introdotto un Controller garantendo l'utilizzo del pattern \textit{MVC}.

Mi sono anche occupato della gestione del movimento del giocatore e delle altre entità (i nemici) all'interno della mappa di gioco. Pertanto, anche in questo caso è stato fatto uso di Controller per consentire la visualizzazione dei nemici in movimento sulla mappa.

Infine, ho implementato la gestione delle condizioni di chiusura del gioco(vittoria e game over), che includevano la definizione delle regole e dei possibili eventi che portavano al termine del gioco, nonché la gestione delle rispettive schermate, come la chiusura del gioco o la possibilità di riavviare una nuova partita.

\subsubsection{Player}
Nell'ambito del progetto del gioco, ho osservato la presenza di caratteristiche comuni tra le diverse entità presenti. Le caratteristiche di base del giocatore sono condivise anche dai vari nemici. 
Pertanto, in collaborazione con \textit{Luca Casadei}, responsabile della parte relativa ai nemici, abbiamo deciso di introdurre nel Model un'interfaccia denominata \textit{GameCharacter}. Questa interfaccia contiene i metodi principali che definiscono le caratteristiche fondamentali comuni a tutte le entità nel gioco, come la vita, la posizione, il movimento e gli attributi.
In aggiunta all'interfaccia, è stata implementata la classe astratta \textit{GameCharacterImpl}, che concretizza l'interfaccia \textit{GameCharacter}. Questa classe è stata progettata in modo che il giocatore, possa estenderla e acquisire le caratteristiche comuni menzionate in precedenza. Questa architettura ci ha consentito di gestire in modo efficiente le proprietà condivise tra il giocatore e i nemici, garantendo una maggiore coerenza e facilità di estensione del codice senza ripetizioni.

Nella gestione del giocatore, ho introdotto un'interfaccia denominata \textit{Player}, che estende l'interfaccia preesistente \textit{GameCharacter}. Successivamente, ho realizzato l'implementazione di questa interfaccia attraverso una classe concreta chiamata \textit{PlayerImpl}. Tale procedura mi ha consentito di definire un comportamento specifico, mantenendo al contempo la flessibilità per estendere e personalizzare le funzionalità di base fornite dall'interfaccia \textit{GameCharacter}.

\begin{figure}[H]
	\centering
	\input{player/the-exiled-player-uml.tex}
	\caption{Schema UML del Model del Player e del GameCharacter}
	\label{fig:the-exiled-player-uml}
\end{figure}

Nella parte inerente alla View sia il giocatore che i nemici sono stati gestiti attraverso una classe chiamata \textit{CharacterView}. Questa classe è stata progettata per utilizzare immagini al fine di rappresentare graficamente le entità del gioco. In particolare, sono state gestite delle animazioni mediante l'utilizzo di due immagini per ciascuna direzione (NORD, SUD, EST e OVEST). Questo approccio è stato adottato per migliorare l'aspetto visivo del gioco e rendere più coinvolgente l'esperienza di gioco. 

La \textit{CharacterView} è una estensione di \textit{JLabel} che gestisce l'aspetto visivo dei personaggi nel gioco. All'interno di questa classe, viene impostata l'immagine che la \textit{JLabel} deve rappresentare, selezionata tra quelle disponibili nelle risorse del gioco. Inizialmente, per il player, viene scelta un'immagine in base alla sua classe, e lo stesso principio si applica ai nemici. Questa classe ausiliaria ci ha permesso di garantire una gestione ottimale della scalabilità della griglia di gioco durante il ridimensionamento della finestra e ci ha permesso inoltre effettuare efficacemente il cambio di immagine per le animazioni.

Per garantire la comunicazione tra il Model e la View del \textit{Player} è stato introdotto un Controller, sotto forma di interfaccia, denominato \textit{CharacterController}. La relativa classe di implementazione invece è stata chiamata \textit{CharacterControllerImpl} dove, al suo interno sono stati definiti i metodi per il controllo del \textit{Player}, tra cui quelli relativi al movimento, all'assegnamento della classe(del tipo), all'uso di modificatori di esperienza e di livello, nonché i relativi metodi Getter necessari per l'interfaccia grafica.

Nel \textit{CharacterController} sono stati definiti metodi generali applicabili a qualsiasi entità presente nel gioco, sia un giocatore o nemico. Per tale motivo, è stata introdotta un'ulteriore interfaccia denominata \textit{CharacterModel}, accompagnata dalla relativa classe \textit{CharacterModelImpl}. Questa struttura consente al controller di gestire entrambe le tipologie di entità in modo uniforme e coerente.

Il design pattern che viene utilizzato per gestire la parte del \textit{Player} è Template Method. Questo pattern consente di definire uno scheletro di comportamento comune per il \textit{Player}. La classe astratta \textit{GameCharacterImpl} costituisce la base per tutte le entità di gioco, ad esempio definisce il metodo \textit{move(Position)}, ossia la struttura generica per il movimento di un'entità. L'interfaccia \textit{Player}, che estende \textit{GameCharacter}, definisce ulteriori metodi specifici del giocatore per il livello, l'esperienza, l'inventario ecc. La classe \textit{PlayerImpl} implementa l'interfaccia \textit{Player} e fornisce le implementazioni specifiche dei metodi definiti nell'interfaccia. Questo approccio favorisce la riutilizzabilità del codice e facilita l'estensione delle funzionalità del \textit{Player} senza dover modificare la struttura di base definita nella classe astratta \textit{GameCharacterImpl}.

\subsubsection{Gestione del movimento}
Nell'ambito dell'implementazione del movimento delle entità all'interno della mappa di gioco, ho adottato due distinzioni principali. Per il movimento del giocatore ho progettato un sistema basato sull'input dell'utente tramite tastiera. D'altra parte, per i nemici, ho sviluppato un meccanismo autonomo di movimento. In pratica, i nemici si spostano in maniera pseudo-casuale all'interno di un'area definita dalla loro tipologia(Fire, Bolt, Water e Grass) e qualora il giocatore si dovesse avvicinare, entro un certo raggio, ad un nemico, quest'ultimo inizierà a inseguirlo per combattere. Questo comportamento è stato realizzato attraverso due metodi: uno per calcolare la distanza tra il giocatore e un nemico (il metodo privato \textit{calculateDistance}), e un altro per determinare la direzione in cui il nemico deve muoversi per inseguire il giocatore (il metodo privato \textit{calculateChaseDirection}). Questo approccio consente un comportamento dinamico e coinvolgente per i nemici, rendendo il gioco più interessante e stimolante per il giocatore, dato che per poter completare il gioco bisogna sconfiggere i quattro Boss che sono situati agli estremi della mappa di gioco.
Considerando la decisione di non impiegare i thread nel nostro progetto, i nemici si sposteranno esclusivamente in risposta all'input dell'utente. Di conseguenza, i nemici si muoveranno solamente quando l'utente eseguirà uno spostamento nella mappa.

In particolare, ho utilizzato il \textit{CharacterModel} per definire il meccanismo di movimento sia per il personaggio che per i nemici. Successivamente, all'interno del \textit{CharacterController}, ho implementato un metodo di movimento che ha richiamato le funzioni precedentemente definite nel Model. Questa scelta è stata fatta per mantenere la separazione delle responsabilità e per organizzare il movimento applicando il pattern \textit{MVC}. Inoltre, nella classe \textit{GameKeyListener} della View, ho gestito l'input dell'utente associando i movimenti alle direzioni corrispondenti ai tasti premuti (ad esempio, W per su, S per giù, A per sinistra e D per	destra). La \textit{GameView} rappresenta la schermata principale dov'è inserita la mappa e l'HUD che visualizza gli attributi principali del personaggio.
Quando l'utente preme un tasto specifico sulla tastiera tra quelli elencati prima, all'interno della \textit{GameView}, il \textit{CharacterView} associato al giocatore si sposterà in una cella corrispondente. Di conseguenza, come precedentemente descritto, tutti i nemici, a meno che non siano vicini al giocatore, si sposteranno anch'essi, in una direzione scelta in modo pseudo-casuale.

Oltre ai KeyListener di base per il movimento del giocatore, ho integrato la funzionalità che permette di utilizzare il tasto E per aprire l'inventario quando si è in gioco e il tasto ESC per aprire/chiudere il menu di gioco. Questa scelta è stata fatta per migliorare l'esperienza di gioco e rendere l'interfaccia più intuitiva e user-friendly, consentendo ai giocatori di navigare facilmente tra le diverse funzionalità senza interruzioni.

Avendo separato la gestione del movimento e dell'ascolto dei \textit{KeyListener} in una classe dedicata, è stato adottato il design pattern Observer. Questo pattern ha consentito di definire un meccanismo di notifica personalizzato attraverso la classe \textit{GameKeyListener}, che funge da Observer. \textit{GameKeyListener} implementa l'interfaccia \textit{KeyListener} e si occupa di ricevere notifiche sugli eventi di pressione dei tasti. In questo modo, sono stato in grado di gestire dinamicamente il movimento delle entità di gioco in risposta all'input dell'utente.

\begin{figure}[H]
	\centering
	\include{movement/the-exiled-movement-uml.tex}
	\caption{Schema UML inerente al meccanismo di movimento}
	\label{fig:the-exiled-movement-uml}
\end{figure}

\subsubsection{Meccanismo di fine gioco}
Mi sono occupato di gestire la conclusione del gioco attraverso due scenari distinti: la vittoria(tramite la \textit{GameVictoryView}) e la sconfitta(tramite \textit{GameOverView}).

Nella parte della sconfitta ho realizzato la gestione del game over attraverso il \textit{GameController}. Utilizzando il metodo \textit{isOver()}, viene deciso quando il gioco è terminato e di conseguenza quando deve essere visualizzata la \textit{GameOverView} dedicata. Avendo un unico metodo per determinare il game over, ho potuto facilmente definire il suo criterio. Essendo un gioco centrato su un singolo giocatore principale, è stato naturale impostare il game over nel caso in cui la sua vita dovesse azzerarsi o scendere sotto lo zero, a seguito di un combattimento con un nemico. 

Lo stesso principio si applica alla GameVictoryView, la quale rappresenta la schermata che compare quando il gioco è completato con successo. Questa View viene attivata quando il metodo \textit{isWon()} restituisce un valore che indica se il giocatore ha vinto il gioco. Per poter vincere il gioco, il personaggio deve avere nel suo inventario i quattro cristalli della redenzione ottenuti sconfiggendo i Boss finali.\\

All'interno delle due schermate, sono stati inclusi due \textit{JButton} con relativi \textit{ActionListener}: uno permette di iniziare una nuova partita e l'altro serve per chiudere definitivamente il gioco.

La \textit{GameOverView} e la \textit{GameVictoryView} sono state integrate all'interno della \textit{GameView}, la schermata principale definita in precedenza. All'interno della sua classe è contenuto il campo del \textit{GameController}, che facilita il collegamento tra il Model e la View stessa. Grazie a questo Controller, è possibile determinare quando la schermata principale deve essere sostituita dalla schermate di vincita o perdita del gioco.

Questo approccio ha semplificato la gestione delle schermate di fine gioco, utilizzando una logica chiara e intuitiva nella scrittura del codice.

\begin{figure}[H]
	\centering
	\include{victory_gameover/the-exiled-victory_gameover-uml.tex}
	\caption{Schema UML del GameOver con relativa vista sulle View}
	\label{fig:the-exiled-victory_gameover-uml}
\end{figure}

Il design pattern applicato alla parte di \textit{GameOverView} e \textit{GameVictoryView}, è il pattern comportamentale Strategy. Le due View rappresentano due strategie diverse per gestire la visualizzazione dell'esito del gioco (game over o vittoria). La classe \textit{GameView} utilizza queste strategie decidendo quale delle due visualizzare in base alle condizioni definite nei metodi \textit{isOver()} e \textit{isWon()} del \textit{GameController}. Utilizzando lo Strategy Pattern, è possibile cambiare dinamicamente il comportamento di \textit{GameView} sostituendo una strategia con un'altra senza modificare il suo codice.

\subsection*{Marco Magnani}
\subsubsection{Item e Inventory}
Per la realizzazione dell'entità degli oggetti ho attuato un'astrazione che fosse più riutilizzabile possibile e che evitasse ripetizioni di codice non necessarie.
In particolare gli oggetti del gioco si dividevano in tre tipi diversi: gli oggetti curativi, di power up e risorse(come per esempio i cristalli). 
Inoltre l'inventario doveva contenere tutti gli item di tipi diversi.

\begin{figure}[H]
	\centering
	\input{item-uml/the-exiled-item-uml.tex}
	\caption{Schema UML del Model degli Item e dell'Inventory}
	\label{fig:the-exiled-item-uml}
\end{figure}

Questa è la struttura che ho pensato, quindi tutti gli item estendono una interfaccia astratta avendo tutti gli stessi campi, gli healing item e power up item inoltre implementano l'interfaccia UsableItem seguendo il \textit{Template Method} pattern, permettendo quindi ad entrambi di implementare la propria logica di utilizzo, il metodo che cambia tra le due implementazioni è la use.

\begin{figure}[H]
	\centering
	\input{item-uml/the-exiled-itemFactory_itemContainer-uml.tex}
	\caption{Schema UML della ItemFactory e dell'ItemContainer}
	\label{fig:the-exiled-itemFactory_itemContainer-uml}
\end{figure}

Qui invece si vede come ho utilizzato il \textit{Factory} pattern per la creazione degli item, in modo tale che chi crea item anche diversi tra loro non debba sapere l'implementazione che ci sta sotto, la factory viene utilizzata dall'item container per la creazione di tutti gli item di gioco. L'Enum ItemNames contiene i nomi di tutti gli oggetti del gioco, i nomi vengono usati come "chiavi" degli item.

%\begin{figure}[H]
%	\centering
%	\input{item-uml/the-exiled-inventory-uml.tex}
%	\caption{Schema UML dell'inventario}
%	\label{fig:the-exiled-inventory-uml}
%\end{figure}

% Commentato perché non faceva compilare dato che non è stato tracciato il file da git e che quindi quando veniva fatto un git pull non si prendeva il file .tex

Tutti gli oggetti sono generalizzati grazie l'interfaccia item e ciò ne semplifica la gestione anche all'interno dell'inventory.
La View dell'inventario segue il pattern \textit{Strategy} in particolare l'interfaccia è la ItemController e la sua implementazione è la ItemControllerImpl.
La classe ItemControllerImpl è responsabile dell'effettiva logica di gestione degli oggetti nel gioco e si interfaccia con il relativo model per gestire l'inventario.
\subsubsection{Hud}
%\begin{figure}[H]
%	\centering
%	\input{hud/the-exiled-hud-uml.tex}
%	\caption{Schema UML della HUD}
%	\label{fig:the-exiled-hud-uml}
%\end{figure}

% Commentato perché non faceva compilare dato che non è stato tracciato il file da git e che quindi quando veniva fatto un git pull non si prendeva il file .tex

Un'altra parte del progetto di cui mi sono occupato è la HUD(head-up display) che mostra sia quando ci si trova sulla pagina principale che durante uno scontro con un nemico le informazioni di base del player, come la sua vita, il livello, la classe e la esperienza.
Questa parte segue il pattern \textit{Observer} ogni volta che il model del player viene modificata, per esempio la vita diminuisce, la HudView viene notificata del cambiamento e può quindi aggiornare la visualizzazione della HUD di conseguenza.
\subsubsection{Levelling}
Infine ho gestito il levelling del giocatore, quindi la logica dell'incremento di livello tramite il raggiungimento di una determinata esperienza, il calcolo della successiva esperienza necessaria, l'incremento delle statistiche ogni incremento di livello, e la logica con cui il player ogni tot livelli impara una mossa nuova.





\subsection*{Manuel Baldoni}


\chapter{Sviluppo}

\section{Testing automatizzato}
\section{Note di sviluppo}

\subsection*{Luca Casadei}
\subsection*{Francesco Pazzaglia}

\begin{itemize}
	\item \textbf{Espressioni Lambda}: Utilizzate nei bottoni che hanno \textit{ActionListener} nella \textit{GameOverView}.
	\item \textbf{Optional}: Utilizzati per sostituire i \textit{null value}, usati nel \textit{CharacterModel}(metodo \textit{getPlayer()}) e anche per il passaggio della \textit{GameView} tra la differenti viste.
	\item \textbf{Stream}: Utilizzati nei Controller per controllare che il \textit{Player} abbia vinto il gioco.
\end{itemize}

\subsection*{Marco Magnani}
\begin{itemize}
	\item \textbf{Stream e Optional}: Utilizzati sia nell' \textit{ItemContainer} che nelle \textit{Moves} per ricavare esempio un item in base al tipo.\\ \url{https://github.com/luca-casadei/the-exiled/blob/71356cacbbef08c33f96d68802a33514823d3571/src/main/java/unibo/exiled/model/item/utilities/ItemsContainer.java#L76C7-L76C8}
	\item \textbf{Stream}: In \textit{CharacterModelImpl} utilizzato per evitare la compenetrazione di enemy all'interno della mappa\\
	\url{https://github.com/luca-casadei/the-exiled/blob/71356cacbbef08c33f96d68802a33514823d3571/src/main/java/unibo/exiled/model/character/CharacterModelImpl.java#L159C1-L160C1} 
	\item \textbf{Optional}: In \textit{ElementalType} e \textit{ItemNames} il metodo per prendere le relative immagini ritorna un Optional per gestire il caso in cui la mossa non sia presente nel progetto\\
	\url{https://github.com/luca-casadei/the-exiled/blob/71356cacbbef08c33f96d68802a33514823d3571/src/main/java/unibo/exiled/model/item/utilities/ItemNames.java#L83C1-L84C55}
	\item \textbf{Stream}: Nella \textit{ItemsModel} utilizzata per la conversione da \textit{Map\textless Item,Integer\textgreater} a \textit{Map\textless String,Integer\textgreater} ed anche per filtrare gli oggetti in base al nome\\
	\url{https://github.com/luca-casadei/the-exiled/blob/71356cacbbef08c33f96d68802a33514823d3571/src/main/java/unibo/exiled/model/item/ItemsModelImpl.java#L28C1-L28C90}
\end{itemize}


\subsection*{Manuel Baldoni}

\chapter{Commenti finali}

\section{Autovalutazione e lavori futuri}

\subsection*{Luca Casadei}
\subsection*{Francesco Pazzaglia}

Nonostante le parti complesse del progetto e il fatto di sviluppare un progetto in team mi avesse inizialmente intimorito, sono soddisfatto di come siamo riusciti a completare e consegnare il gioco. Di solito sono abituato a lavorare da solo, ma ho trovato la collaborazione in team piuttosto soddisfacente. Lo scambio di idee e il confronto ci hanno aiutato a coordinarci efficacemente, individuando i metodi e le classi necessarie per varie parti del progetto. Lavorare in team è stato molto formativo e mi ha permesso di apprezzare come si possa realizzare un progetto insieme, nonostante stili di programmazione talvolta diversi.

\subsection*{Marco Magnani}
\subsection*{Manuel Baldoni}

\section{Difficoltà incontrate e commenti per i docenti}

\appendix
\chapter{Guida utente}

\chapter{Esercitazioni di laboratorio}
Elenco dei Permalink delle consegne nel forum studenti del modulo di laboratorio.
\section*{Consegne}
\subsection{luca.casadei27@studio.unibo.it}
\begin{itemize}
	\item Laboratorio 06: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=146511#p208401}
	\item Laboratorio 07: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=147598#p209323}
	\item Laboratorio 08: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=148025#p209782}
	\item Laboratorio 09: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=149231#p211336}
	\item Laboratorio 10: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=150252#p212475}
\end{itemize}

\end{document}