\documentclass[a4paper,12pt]{report}

\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{hyperref}
\usepackage{tikz}

% Questo commentalo se vuoi scrivere in inglese.
\usepackage[italian]{babel}

\usepackage[italian]{cleveref}

\title{Progetto di Programmazione ad Oggetti\\``The Exiled''}

\author{Luca Casadei, Francesco Pazzaglia, Marco Magnani, Manuel Baldoni}
\date{\today}


\begin{document}

\maketitle

\tableofcontents

\chapter{Analisi}

\section{Requisiti}
L'applicazione è un gioco che presenta un personaggio controllato dal giocatore con la possibilità di muoversi nella mappa in 4 direzioni e di combattere contro dei nemici utilizzando magie elementali. I nemici sconfitti potrebbero rilasciare delle cure o dei potenziamenti che favoriscono il giocatore. Per concludere il gioco, il giocatore deve entrare in possesso di 4 cristalli che vengono consegnati una volta sconfitti i 4 boss del gioco che sono nemici più difficili da sconfiggere.
\subsection*{Requisiti funzionali}
\begin{itemize}
    \item Movimento del giocatore.
    \item Movimento dei nemici.
    \item Presenza di oggetti ottenibili dal giocatore (Cure, potenziamenti e cristalli).
    \item Terminazione del gioco una volta raccolti 4 cristalli o se il giocatore viene sconfitto.
    \item Posizionamento e distribuzione degli oggetti.
    \item Possibilità di fare battaglie tra giocatore e nemici.
    \item Nemici più forti (boss) che se sconfitti rilasciano i cristalli per terminare il gioco.
    \item Possibilità di utilizzo di magie in battaglia di diverso tipo (Fuoco, Acqua, Fulmine, Erba).
    \item Aumento di livello tramite guadagno di esperienza sconfiggendo i nemici.
\end{itemize}

\subsection*{Requisiti non funzionali}
\begin{itemize}
    \item Il gioco deve essere multipiattaforma.
    \item \textit{TODO}
\end{itemize}

\section{Analisi e modello del dominio}

All'inizio al giocatore viene chiesto di che tipo elementale sarà il personaggio da controllare, in base a questa scelta gli verrà quindi assegnata una mossa di base di quel tipo e avrà le mosse di quel tipo potenziate fino alla fine del gioco.\\
Il giocatore può muoversi di una cella alla volta in una mappa a griglia in 4 direzioni (Nord, Est, Sud, Ovest) e una battaglia con i nemici (anch'essi di un certo tipo elementale) inizia quando la cella in cui è il giocatore combacia con quella di un nemico.\\
Per affrontare un nemico in battaglia il giocatore ha a disposizione massimo 4 mosse (non per forza dello stesso tipo del giocatore). Il combattimento avviene a turni alternati, il primo è il giocatore, poi il nemico e così via finché uno dei due viene sconfitto, se è il giocatore, il gioco termina.\\
Allo sconfiggere dei nemici viene conferita al giocatore una certa quantità di esperienza che serve ad aumentare di livello e un oggetto casuale, l'oggetto viene salvato nell'inventario del giocatore e potrà essere di diverso tipo, es. oggetto curativo(ripristina un tot di vita), booster di statistiche(per esempio aumenta l'attacco di un certo tipo di mosse) ecc.. L'aumento di livello comporta un incremento generale delle statistiche ovvero attacco, difesa e vita di un valore costante. Ogni 5 livelli verrà presentata al giocatore la possibilità di imparare una nuova mossa di un tipo casuale, se il giocatore ha già 4 mosse potrà decidere di scambiare quella nuova con una di quelle che conosce già. All'aumentare di livello sarà richiesta sempre più esperienza per passare a quello successivo.\\
Ci sono diverse classi di nemico, alcuni più deboli e altri più forti, come i boss, che se sconfitti consegnano uno dei 4 oggetti necessari per concludere il gioco (i cristalli).\\

\subsection{Tipi elementali}
I seguenti sono i tipi elementali presenti, ognuno è efficace rispetto ad un altro, quindi quando vengono usate mosse di un certo tipo che risulta essere efficace rispetto al tipo di un nemico, si avranno dei moltiplicatori del danno. Lo stesso vale per i nemici che usano mosse di un tipo efficace rispetto a quello scelto dal giocatore all'inizio.
\\\\
Ad esempio, nel seguente schema si vede che Fulmine è efficace contro Acqua.


\begin{center}
\begin{tabular}{ c c c }
    Fulmine & $\rightarrow$ & Acqua \\
    Erba & $\rightarrow$ & Fulmine \\
    Acqua & $\rightarrow$ & Fuoco \\
    Fuoco & $\rightarrow$ & Erba \\
\end{tabular}
\end{center}

\subsection{UML}
\begin{figure}[H]
	\centering
	\input{the-exiled-uml.tex}
	\caption{Schema UML del dominio.} \label{fig:Schema UML del dominio.}
\end{figure}

\chapter{Design}

Qui entriamo nel dettaglio della struttura ad alto livello del gioco.

\section{Architettura}
\section{Design dettagliato}

\subsection*{Luca Casadei}
La parte di creazione dei nemici è stata realizzata utilizzando il pattern creazionale "Abstract Factory"

\subsection*{Francesco Pazzaglia}
La mia parte di progetto si concentra sull'implementazione dettagliata del giocatore, comprendendo la definizione delle sue caratteristiche quali attributi(la vita, l'esperienza, la relativa classe...) e le sue meccaniche in gioco. Per facilitare la comunicazione tra il Model del giocatore (\textit{Player}) e la View ho introdotto un controller garantendo l'utilizzo del pattern \textit{MVC}.

Mi sono occupato della gestione del movimento del giocatore e delle altre entità (i nemici) all'interno della mappa di gioco. Pertanto, anche in questo caso è stato fatto uso di controller per consentire la visualizzazione dei nemici in movimento sulla mappa.

Infine, ho implementato la gestione delle condizioni di chiusura del gioco(vittoria e game over), che includevano la definizione delle regole e dei possibili eventi che portavano al termine del gioco, nonché la gestione delle rispettive schermate, come la chiusura del gioco o la possibilità di far ripartire una nuova partita.

\subsubsection{Player}
Nell'ambito del progetto del gioco, ho osservato una serie di caratteristiche comuni tra le diverse entità presenti nel gioco. Le caratteristiche di base del giocatore sono condivise anche dai vari nemici. 
Pertanto, in collaborazione con \textit{Luca Casadei}, responsabile della parte relativa ai nemici, abbiamo deciso di introdurre nel Model un'interfaccia denominata \textit{GameCharacter}. Questa interfaccia contiene i metodi principali che definiscono le caratteristiche fondamentali comuni a tutte le entità nel gioco, come la vita, la posizione, il movimento e gli attributi.
In aggiunta all'interfaccia, è stata implementata la classe astratta \textit{GameCharacterImpl}, che concretizza l'interfaccia \textit{GameCharacter}. Questa classe è stata progettata in modo che il giocatore, e di conseguenza anche i nemici, possano estenderla e acquisire le caratteristiche comuni menzionate in precedenza. Questa architettura ci ha consentito di gestire in modo efficiente le proprietà condivise tra il giocatore e i nemici, garantendo una maggiore coerenza e facilità di estensione del codice senza ripetizioni.

Nella gestione del giocatore, ho introdotto un'interfaccia denominata \textit{Player}, che estende l'interfaccia preesistente \textit{GameCharacter}. Successivamente, ho realizzato l'implementazione di questa interfaccia attraverso una classe concreta chiamata \textit{PlayerImpl}. Tale procedura mi ha consentito di definire un comportamento specifico, mantenendo al contempo la flessibilità per estendere e personalizzare le funzionalità di base fornite dall'interfaccia \textit{GameCharacter}.

\begin{figure}[H]
	\centering
	\input{player/the-exiled-player-uml.tex}
	\caption{Schema UML del Model del Player e del GameCharacter}
	\label{fig:the-exiled-player-uml}
\end{figure}

Nella parte inerente alla View sia il giocatore che i nemici sono stati gestiti attraverso una classe chiamata \textit{CharacterView}. Questa classe è stata progettata per utilizzare immagini al fine di rappresentare graficamente le entità del gioco. In particolare, sono state gestite delle animazioni mediante l'utilizzo di due immagini per ciascuna direzione (NORD, SUD, EST e OVEST). Questo approccio è stato adottato per migliorare l'aspetto visivo del gioco e rendere più coinvolgente l'esperienza di gioco. 

La \textit{CharacterView} è una estensione di \textit{JLabel} che gestisce l'aspetto visivo dei personaggi nel gioco. All'interno di questa classe, viene impostata l'immagine che la JLabel deve rappresentare, selezionata tra quelle disponibili nelle risorse del gioco. Inizialmente, per il player, viene scelta un'immagine in base alla sua classe, e lo stesso principio si applica ai nemici. Questa classe ausiliaria ci ha permesso di garantire una gestione ottimale della scalabilità della griglia di gioco durante il ridimensionamento della finestra e di effettuare efficacemente il cambio di immagine per le animazioni.

Per garantire la comunicazione tra il Model e la View del \textit{Player} è stato introdotto un Controller, sotto forma di interfaccia, denominato \textit{CharacterController}. La relativa classe di implementazione invece è stata chiamata \textit{CharacterControllerImpl} dove, al suo interno sono stati definiti i metodi per il controllo del \textit{Player}, tra cui \textit{movePlayer(Direction)}, \textit{assignPlayerClass(ElementalType)}, \textit{addPlayerExperience(int)}, nonché i relativi metodi Getter necessari per l'interfaccia grafica.

Il design pattern che viene utilizzato per gestire la parte del \textit{Player} è Template Method. Questo pattern consente di definire uno scheletro di comportamento comune per il \textit{Player}, delegando l'implementazione di alcuni metodi specifici alle sue sottoclassi. La classe astratta \textit{GameCharacterImpl} costituisce la base per tutte le entità di gioco e definisce il metodo \textit{move(Position)}, che stabilisce uno scheletro per il movimento di un'entità. L'interfaccia \textit{Player}, che estende \textit{GameCharacter}, definisce ulteriori metodi specifici del giocatore per il livello, l'esperienza, l'inventario ecc. La classe \textit{PlayerImpl} implementa l'interfaccia \textit{Player} e fornisce le implementazioni specifiche dei metodi definiti nell'interfaccia. Questo approccio favorisce la riutilizzabilità del codice e facilita l'estensione delle funzionalità del \textit{Player} senza dover modificare la struttura di base definita nella classe astratta GameCharacterImpl.

\subsubsection{Gestione del movimento}
Nell'ambito dell'implementazione del movimento delle entità all'interno della mappa di gioco, ho adottato due distinzioni principali. Per il movimento del giocatore ho progettato un sistema basato sull'input dell'utente tramite tastiera. D'altra parte, per i nemici, ho sviluppato un meccanismo autonomo di movimento. In pratica, i nemici si spostano in maniera pseudo-casuale all'interno di un'area definita dal loro tipo(Fire, Bolt, Water e Grass) e qualora il giocatore si dovesse avvicinare entro un certo raggio da un nemico, quest'ultimo inizierà a inseguirlo per combattere. Questo comportamento è stato realizzato attraverso due metodi: uno per calcolare la distanza tra il giocatore e un nemico (il metodo privato \textit{calculateDistance}), e un altro per determinare la direzione in cui il nemico deve muoversi per inseguire il giocatore (il metodo privato \textit{calculateChaseDirection}). Questo approccio consente un comportamento dinamico e coinvolgente per i nemici, rendendo il gioco più interessante e stimolante per il giocatore, dato che per poter completare il gioco bisogna sconfiggere i 4 Boss che sono situati agli estremi della mappa di gioco.
Considerando la decisione di non impiegare i thread nel nostro progetto, i nemici si sposteranno esclusivamente in risposta all'input dell'utente. Di conseguenza, i nemici si muoveranno solamente quando l'utente eseguirà uno spostamento nella mappa.

In particolare, ho utilizzato il \textit{CharacterModel} per definire il comportamento del movimento sia per il personaggio che per i nemici. Successivamente, all'interno del \textit{CharacterController}, ho implementato un metodo di movimento che ha richiamato le funzioni precedentemente definite nel Model. Questa scelta è stata fatta per mantenere la separazione delle responsabilità e per organizzare il movimento applicando il pattern \textit{MVC}. Inoltre, nella classe \textit{GameKeyListener} della View, ho gestito l'input dell'utente associando i movimenti alle direzioni corrispondenti ai tasti premuti (ad esempio, W per su, S per giù, A per sinistra e D per 	destra). La \textit{GameView} rappresenta la schermata principale con la mappa e l'HUD relativa agli attributi del personaggio.
Quando l'utente preme un tasto specifico sulla tastiera tra quelli elencati prima, all'interno della \textit{GameView}, il \textit{CharacterView} associato al giocatore si sposterà in una cella corrispondente. Di conseguenza, come precedentemente descritto, tutti i nemici, a meno che non siano vicini al giocatore, si sposteranno anch'essi, in una direzione scelta in modo pseudo-casuale.

Oltre ai KeyListener di base per il movimento del giocatore, ho integrato la funzionalità di utilizzare il tasto E per aprire l'inventario quando si è in gioco e il tasto ESC per aprire/chiudere il menu di gioco. Questa scelta è stata fatta per migliorare l'esperienza di gioco e rendere l'interfaccia più intuitiva e user-friendly, consentendo ai giocatori di navigare facilmente tra le diverse funzionalità senza interruzioni.

Avendo separato la gestione del movimento e dell'ascolto dei KeyListener in una classe dedicata, è stato adottato il design pattern Observer. Questo pattern ha consentito di definire un meccanismo di notifica personalizzato attraverso la classe \textit{GameKeyListener}, che funge da Observer. GameKeyListener implementa l'interfaccia KeyListener e si registra per ricevere notifiche sugli eventi di pressione dei tasti. In questo modo, sono stati in grado di gestire dinamicamente il movimento delle entità di gioco in risposta all'input dell'utente.

% TODO: mettere la figura UML.

\subsubsection{Meccanismo di fine gioco}
Mi sono occupato di gestire la conclusione del gioco attraverso due scenari distinti: la vittoria(tramite la \textit{GameVictoryView}) e la sconfitta(tramite \textit{GameOverView}).

Nella parte della sconfitta ho implementato la gestione del game over attraverso il \textit{GameController}. Utilizzando il metodo \textit{isOver()}, viene deciso quando il gioco è terminato e di conseguenza quando deve essere visualizzata la \textit{GameOverView} dedicata. Avendo un unico metodo per determinare il game over, ho potuto facilmente definire il suo criterio. Essendo un gioco centrato su un singolo giocatore principale, è stato naturale impostare il game over nel caso in cui la sua vita dovesse azzerarsi o scendere sotto lo zero, a seguito di un combattimento con un nemico. 

Lo stesso principio si applica alla GameVictoryView, la quale rappresenta la schermata che compare quando il gioco è completato con successo. Questa vista viene attivata quando il metodo \textit{isWon()} restituisce un valore che indica se il giocatore ha vinto il gioco, e che di conseguenza, nel suo inventario ci sono i quattro cristalli della redenzione ottenuti sconfiggendo i Boss finali.\\

All'interno delle due schermate, sono stati inclusi due \textit{JButton} con relativi \textit{ActionListener}: uno permette di iniziare una nuova partita e l'altro serve per chiudere definitivamente il gioco.

La \textit{GameOverView} e la \textit{GameVictoryView} sono state integrate all'interno della \textit{GameView}, la schermata principale definita in precedenza. All'interno della sua classe è contenuto il campo inerente al \textit{GameController}, che facilita il collegamento tra il Model e la View stessa. Grazie a questo Controller, è possibile determinare quando la schermata principale deve essere sostituita dalla schermate di vincita o perdita del gioco.

Questo approccio ha semplificato la gestione delle schermate di fine gioco, utilizzando una logica chiara e intuitiva nella scrittura del codice.

\begin{figure}[H]
	\centering
	\include{victory_gameover/the-exiled-victory_gameover-uml.tex}
	\caption{Schema UML del GameOver con relativa vista sulle View}
	\label{fig:the-exiled-victory_gameover-uml}
\end{figure}

Il design pattern applicato alla parte di \textit{GameOverView} e \textit{GameVictoryView}, è il pattern comportamentale Strategy. Le due View rappresentano due strategie diverse per gestire la visualizzazione dell'esito del gioco (game over o vittoria). La classe \textit{GameView} agisce come il contesto che utilizza queste strategie, decidendo quale delle due visualizzare in base alle condizioni definite nei metodi \textit{isOver()} e \textit{isWon()} del \textit{GameController}. Utilizzando lo Strategy Pattern, è possibile cambiare dinamicamente il comportamento di \textit{GameView} sostituendo una strategia con un'altra senza modificare il suo codice.

\subsection*{Marco Magnani}

\subsection*{Manuel Baldoni}


\chapter{Sviluppo}

\section{Testing automatizzato}
\section{Note di sviluppo}

\subsection*{Luca Casadei}
\subsection*{Francesco Pazzaglia}

\begin{itemize}
	\item \textbf{Espressioni Lambda}: Utilizzate nei bottoni che hanno \textit{ActionListener} nella \textit{GameOverView}.
	\item \textbf{Optional}: Utilizzati per sostituire i \textit{null value}, usati nel \textit{CharacterModel}(metodo \textit{getPlayer()}) e anche per il passaggio della \textit{GameView} tra la differenti viste.
	\item \textbf{Stream}: Utilizzati nei Controller per controllare che il \textit{Player} abbia vinto il gioco.
\end{itemize}

\subsection*{Marco Magnani}
\subsection*{Manuel Baldoni}

\chapter{Commenti finali}

\section{Autovalutazione e lavori futuri}

\subsection*{Luca Casadei}
\subsection*{Francesco Pazzaglia}

Nonostante le parti complesse del progetto e il fatto di sviluppare un progetto in team mi avesse inizialmente intimorito, sono soddisfatto di come siamo riusciti a completare e consegnare il gioco. Di solito sono abituato a lavorare da solo, ma ho trovato la collaborazione in team piuttosto soddisfacente. Lo scambio di idee e il confronto ci hanno aiutato a coordinarci efficacemente, individuando i metodi e le classi necessarie per varie parti del progetto. Lavorare in team è stato molto formativo e mi ha permesso di apprezzare come si possa realizzare un progetto insieme, nonostante stili di programmazione talvolta diversi.

\subsection*{Marco Magnani}
\subsection*{Manuel Baldoni}

\section{Difficoltà incontrate e commenti per i docenti}

\appendix
\chapter{Guida utente}

\chapter{Esercitazioni di laboratorio}
Elenco dei Permalink delle consegne nel forum studenti del modulo di laboratorio.
\section*{Consegne}
\subsection{luca.casadei27@studio.unibo.it}
\begin{itemize}
	\item Laboratorio 06: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=146511#p208401}
	\item Laboratorio 07: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=147598#p209323}
	\item Laboratorio 08: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=148025#p209782}
	\item Laboratorio 09: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=149231#p211336}
	\item Laboratorio 10: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=150252#p212475}
\end{itemize}

\end{document}