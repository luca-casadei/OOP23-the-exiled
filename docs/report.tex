\documentclass[a4paper,12pt]{report}

\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{hyperref}
\usepackage{tikz}

% Questo commentalo se vuoi scrivere in inglese.
\usepackage[italian]{babel}

\usepackage[italian]{cleveref}

\title{Progetto di Programmazione ad Oggetti\\``The Exiled''}

\author{Luca Casadei, Francesco Pazzaglia, Marco Magnani, Manuel Baldoni}
\date{\today}


\begin{document}

\maketitle

\tableofcontents

\chapter{Analisi}

\section{Requisiti}
L'applicazione è un gioco che presenta un personaggio controllato dal giocatore con la possibilità di muoversi nella mappa in 4 direzioni e di combattere contro dei nemici utilizzando magie elementali. I nemici sconfitti potrebbero rilasciare delle cure o dei potenziamenti che favoriscono il giocatore. Per concludere il gioco, il giocatore deve entrare in possesso di 4 cristalli che vengono consegnati una volta sconfitti i 4 boss del gioco che sono nemici più difficili da sconfiggere.
\subsection*{Requisiti funzionali}
\begin{itemize}
    \item Movimento del giocatore.
    \item Movimento dei nemici.
    \item Presenza di oggetti ottenibili dal giocatore (Cure, potenziamenti e cristalli).
    \item Terminazione del gioco una volta raccolti 4 cristalli o se il giocatore viene sconfitto.
    \item Posizionamento e distribuzione degli oggetti.
    \item Possibilità di fare battaglie tra giocatore e nemici.
    \item Nemici più forti (boss) che se sconfitti rilasciano i cristalli per terminare il gioco.
    \item Possibilità di utilizzo di magie in battaglia di diverso tipo (Fuoco, Acqua, Fulmine, Erba).
    \item Aumento di livello tramite guadagno di esperienza sconfiggendo i nemici.
\end{itemize}

\subsection*{Requisiti non funzionali}
\begin{itemize}
    \item Il gioco deve essere multipiattaforma.
    \item \textit{TODO}
\end{itemize}

\section{Analisi e modello del dominio}

All'inizio al giocatore viene chiesto di che tipo elementale sarà il personaggio da controllare, in base a questa scelta gli verrà quindi assegnata una mossa di base di quel tipo e avrà le mosse di quel tipo potenziate fino alla fine del gioco.\\
Il giocatore può muoversi di una cella alla volta in una mappa a griglia in 4 direzioni (Nord, Est, Sud, Ovest) e una battaglia con i nemici (anch'essi di un certo tipo elementale) inizia quando la cella in cui è il giocatore combacia con quella di un nemico.\\
Per affrontare un nemico in battaglia il giocatore ha a disposizione massimo 4 mosse (non per forza dello stesso tipo del giocatore). Il combattimento avviene a turni alternati, il primo è il giocatore, poi il nemico e così via finché uno dei due viene sconfitto, se è il giocatore, il gioco termina.\\
Allo sconfiggere dei nemici viene conferita al giocatore una certa quantità di esperienza che serve ad aumentare di livello e un oggetto casuale, l'oggetto viene salvato nell'inventario del giocatore e potrà essere di diverso tipo, es. oggetto curativo(ripristina un tot di vita), booster di statistiche(per esempio aumenta l'attacco di un certo tipo di mosse) ecc.. L'aumento di livello comporta un incremento generale delle statistiche ovvero attacco, difesa e vita di un valore costante. Ogni 5 livelli verrà presentata al giocatore la possibilità di imparare una nuova mossa di un tipo casuale, se il giocatore ha già 4 mosse potrà decidere di scambiare quella nuova con una di quelle che conosce già. All'aumentare di livello sarà richiesta sempre più esperienza per passare a quello successivo.\\
Ci sono diverse classi di nemico, alcuni più deboli e altri più forti, come i boss, che se sconfitti consegnano uno dei 4 oggetti necessari per concludere il gioco (i cristalli).\\

\subsection{Tipi elementali}
I seguenti sono i tipi elementali presenti, ognuno è efficace rispetto ad un altro, quindi quando vengono usate mosse di un certo tipo che risulta essere efficace rispetto al tipo di un nemico, si avranno dei moltiplicatori del danno. Lo stesso vale per i nemici che usano mosse di un tipo efficace rispetto a quello scelto dal giocatore all'inizio.
\\\\
Ad esempio, nel seguente schema si vede che Fulmine è efficace contro Acqua.


\begin{center}
\begin{tabular}{ c c c }
    Fulmine & $\rightarrow$ & Acqua \\
    Erba & $\rightarrow$ & Fulmine \\
    Acqua & $\rightarrow$ & Fuoco \\
    Fuoco & $\rightarrow$ & Erba \\
\end{tabular}
\end{center}

\subsection{UML}
\begin{figure}[H]
	\centering
	\input{the-exiled-uml.tex}
	\caption{Schema UML del dominio.} \label{fig:Schema UML del dominio.}
\end{figure}

\chapter{Design}

Qui entriamo nel dettaglio della struttura ad alto livello del gioco.

\section{Architettura}
\section{Design dettagliato}

\subsection*{Luca Casadei}

\subsection*{Francesco Pazzaglia}
La mia parte di progetto si concentra sull'implementazione dettagliata del giocatore, comprendendo la definizione delle sue caratteristiche quali attributi(la vita, l'esperienza, la relativa classe...) e le sue meccaniche in gioco. Per facilitare la comunicazione tra il Model del giocatore (\textit{Player}) e la View ho introdotto un controller garantendo l'utilizzo del pattern \textit{MVC}.

Mi sono occupato della gestione del movimento del giocatore e delle altre entità (i nemici) all'interno della mappa di gioco. Pertanto, anche in questo caso è stato fatto uso di controller per consentire la visualizzazione dei nemici in movimento sulla mappa.

Infine, ho implementato la gestione delle condizioni di Game Over, che includevano la definizione delle regole e dei possibili eventi che portavano al termine del gioco, nonché la gestione delle rispettive schermate, come la chiusura del gioco o la possibilità di far ripartire una nuova partita.

\subsubsection{Player}
Nell'ambito del progetto del gioco, ho osservato una serie di caratteristiche comuni tra le diverse entità presenti nel gioco. Le caratteristiche di base del giocatore sono condivise anche dai vari nemici. 
Pertanto, in collaborazione con \textit{Luca Casadei}, responsabile della parte relativa ai nemici, abbiamo deciso di introdurre nel Model un'interfaccia denominata \textit{GameCharacter}. Questa interfaccia contiene i metodi principali che definiscono le caratteristiche fondamentali comuni a tutte le entità nel gioco, come la vita, la posizione, il movimento e gli attributi.
In aggiunta all'interfaccia, è stata implementata la classe astratta \textit{GameCharacterImpl}, che concretizza l'interfaccia \textit{GameCharacter}. Questa classe è stata progettata in modo che il giocatore, e di conseguenza anche i nemici, possano estenderla e acquisire le caratteristiche comuni menzionate in precedenza. Questa architettura ci ha consentito di gestire in modo efficiente le proprietà condivise tra il giocatore e i nemici, garantendo una maggiore coerenza e facilità di estensione del codice senza ripetizioni.

Nella gestione del giocatore, ho introdotto un'interfaccia denominata \textit{Player}, che estende l'interfaccia preesistente \textit{GameCharacter}. Successivamente, ho realizzato l'implementazione di questa interfaccia attraverso una classe concreta chiamata \textit{PlayerImpl}. Tale procedura mi ha consentito di definire un comportamento specifico, mantenendo al contempo la flessibilità per estendere e personalizzare le funzionalità di base fornite dall'interfaccia \textit{GameCharacter}.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{PlayerUML.png}
	\caption{Schema UML del Model del Player e del GameCharacter}
	\label{fig:diagramma-classe-player}
\end{figure}

La struttura del Model è stata progettata seguendo il Composite Pattern. In particolare, si parte dall'interfaccia \textit{CharacterModel} con la relativa classe \textit{CharacterModelImpl} che rappresenta la sua implementazione. La \textit{CharacterModelImpl} è stata configurata per contenere un elemento dell'interfaccia \textit{Player} e una collezione di nemici. Questa configurazione organizza la struttura del modello come un albero, dove \textit{CharacterModelImpl} funge da componente composito che contiene sia il giocatore che la collezione di nemici al suo interno.

Nella parte inerente alla View sia il giocatore che i nemici sono stati gestiti attraverso una singola classe chiamata \textit{CharacterView}. Questa classe è stata progettata per utilizzare immagini al fine di rappresentare graficamente le entità del gioco. In particolare, sono state gestite delle animazioni mediante l'utilizzo di due immagini per ciascuna direzione (NORD, SUD, EST e OVEST). Questo approccio è stato adottato per migliorare l'aspetto visivo del gioco e rendere più coinvolgente l'esperienza di gioco. 

La \textit{CharacterView} è una estensione di \textit{JLabel} che gestisce l'aspetto visivo dei personaggi nel gioco. All'interno di questa classe, viene impostata l'immagine che la JLabel deve rappresentare, selezionata tra quelle disponibili nelle risorse del gioco. Inizialmente, per il player, viene scelta un'immagine in base alla sua classe, e lo stesso principio si applica ai nemici. Questa classe ausiliaria ci ha permesso di garantire una gestione ottimale della scalabilità della griglia di gioco durante il ridimensionamento della finestra e di effettuare efficacemente il cambio di immagine per le animazioni.

Per garantire la comunicazione tra il Model e la View del \textit{Player} è stato introdotto un Controller, sotto forma di interfaccia, denominato \textit{CharacterController}. La relativa classe di implementazione invece è stata chiamata \textit{CharacterControllerImpl} dove, al suo interno sono stati definiti i metodi per il controllo del \textit{Player}, tra cui \textit{movePlayer(Direction)}, \textit{assignPlayerClass(ElementalType)}, \textit{addPlayerExperience(int)}, nonché i relativi metodi Getter necessari per l'interfaccia grafica.

\subsubsection{Gestione del movimento}
Nell'ambito dell'implementazione del movimento delle entità all'interno della mappa di gioco, ho adottato due distinzioni principali. Per il movimento del giocatore ho progettato un sistema basato sull'input dell'utente tramite tastiera. D'altra parte, per i nemici, ho sviluppato un meccanismo autonomo di movimento. In pratica, i nemici si spostano in maniera pseudo-casuale all'interno di un'area definita dal loro tipo(Fire, Bolt, Water e Grass) e qualora il giocatore si dovesse avvicinare entro un certo raggio da un nemico, quest'ultimo inizierà a inseguirlo per combattere. Questo comportamento è stato realizzato attraverso due metodi: uno per calcolare la distanza tra il giocatore e un nemico (il metodo privato \textit{calculateDistance}), e un altro per determinare la direzione in cui il nemico deve muoversi per inseguire il giocatore (il metodo privato \textit{calculateChaseDirection}). Questo approccio consente un comportamento dinamico e coinvolgente per i nemici, rendendo il gioco più interessante e stimolante per il giocatore, dato che per poter completare il gioco bisogna sconfiggere i 4 Boss che sono situati agli estremi della mappa di gioco.
Considerando la decisione di non impiegare i thread nel nostro progetto, i nemici si sposteranno esclusivamente in risposta all'input dell'utente. Di conseguenza, i nemici si muoveranno solamente quando l'utente eseguirà uno spostamento nella mappa.

In particolare, ho utilizzato il \textit{CharacterModel} per definire il comportamento del movimento sia per il personaggio che per i nemici. Successivamente, all'interno del \textit{CharacterController}, ho implementato un metodo di movimento che ha richiamato le funzioni precedentemente definite nel Model. Questa scelta è stata fatta per mantenere la separazione delle responsabilità e per organizzare il movimento applicando il pattern \textit{MVC}. Inoltre, nella classe \textit{GameKeyListener} della View, ho gestito l'input dell'utente associando i movimenti alle direzioni corrispondenti ai tasti premuti (ad esempio, W per su, S per giù, A per sinistra e D per 	destra). La \textit{GameView} rappresenta la schermata principale con la mappa e l'HUD relativa agli attributi del personaggio.
Quando l'utente preme un tasto specifico sulla tastiera tra quelli elencati prima, all'interno della \textit{GameView}, il \textit{CharacterView} associato al giocatore si sposterà in una cella corrispondente. Di conseguenza, come precedentemente descritto, tutti i nemici, a meno che non siano vicini al giocatore, si sposteranno anch'essi, in una direzione scelta in modo pseudo-casuale.

Oltre ai KeyListener di base per il movimento del giocatore, ho integrato la funzionalità di utilizzare il tasto E per aprire l'inventario quando si è in gioco e il tasto ESC per aprire/chiudere il menu di gioco. Questa scelta è stata fatta per migliorare l'esperienza di gioco e rendere l'interfaccia più intuitiva e user-friendly, consentendo ai giocatori di navigare facilmente tra le diverse funzionalità senza interruzioni.

Avendo gestito il movimento e l'ascolto dei KeyListener in una classe separata, è stato utilizzato il design pattern strutturale Adapter. Questo pattern ci ha permesso di gestire in modo personalizzato i KeyListener attraverso la classe GameKeyListener, che implementa l'interfaccia KeyListener. Grazie a questa implementazione, siamo in grado di risolvere efficacemente il problema della gestione del movimento delle diverse entità all'interno del gioco.

\subsubsection{Meccanismo di Game Over}
Ho implementato la gestione del Game Over attraverso il \textit{GameController}. Utilizzando il metodo \textit{isOver()}, viene deciso quando il gioco è terminato e di conseguenza quando deve essere visualizzata la \textit{GameOverView} dedicata. Avendo un unico metodo per determinare il Game Over, ho potuto facilmente definire il suo criterio. Essendo un gioco centrato su un singolo giocatore principale, è stato naturale impostare il Game Over nel caso in cui la sua vita dovesse azzerarsi o scendere sotto lo zero, a seguito di un combattimento con un nemico. Questo approccio ha semplificato la gestione del Game Over, utilizzando una logica chiara e intuitiva nella scrittura del codice.

All'interno della \textit{GameOverView}, sono stati inclusi due \textit{JButton} con relativi \textit{ActionListener}: uno permette di iniziare una nuova partita e l'altro serve per chiudere definitivamente il gioco.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{GameOverUML.png}
	\caption{Schema UML del GameOver con relativa vista sulle View}
	\label{fig:diagramma-classe-GameOver}
\end{figure}

La \textit{GameOverView} è stata integrata all'interno della \textit{GameView}, la schermata principale definita in precedenza. All'interno di questa \textit{GameView} è anche presente il \textit{GameController}, che facilita il collegamento tra il Model e la View stessa. Grazie a questo Controller, è possibile determinare quando la schermata principale deve essere sostituita dalla schermata di Game Over.

Il pattern architetturale impiegato per gestire la visualizzazione della \textit{GameOverView} nel metodo \textit{draw()} della classe \textit{GameView} è il noto Facade.
Quando il gioco giunge al termine, la \textit{GameOverView} viene mostrata in modo condizionale attraverso il metodo prima citato fornito dal \textit{GameController}. Questo approccio consente di occultare la complessità interna associata alla visualizzazione della \textit{GameOverView} e di semplificare l'interazione con essa all'interno di un unico metodo della \textit{GameView}.

\subsection*{Marco Magnani}

\subsection*{Manuel Baldoni}


\chapter{Sviluppo}

\section{Testing automatizzato}
\section{Note di sviluppo}

\subsection*{Luca Casadei}
\subsection*{Francesco Pazzaglia}

\begin{itemize}
	\item \textbf{Espressioni Lambda}: Utilizzate nei bottoni che hanno ActionListener nella GameOverView.
	\item \textbf{Optional}: Utilizzati per sostituire i \textit{null value}, usati nel CharacterModel(metodo 			 	\textit{getPlayer()}) e anche per il passaggio della GameView tra la differenti viste.
\end{itemize}

\subsection*{Marco Magnani}
\subsection*{Manuel Baldoni}

\chapter{Commenti finali}

\section{Autovalutazione e lavori futuri}

\subsection*{Luca Casadei}
\subsection*{Francesco Pazzaglia}

Nonostante le parti complesse del progetto e il fatto di sviluppare un progetto in team mi avesse inizialmente intimorito, sono soddisfatto di come siamo riusciti a completare e consegnare il gioco. Di solito sono abituato a lavorare da solo, ma ho trovato la collaborazione in team piuttosto soddisfacente. Lo scambio di idee e il confronto ci hanno aiutato a coordinarci efficacemente, individuando i metodi e le classi necessarie per varie parti del progetto. Lavorare in team è stato molto formativo e mi ha permesso di apprezzare come si possa realizzare un progetto insieme, nonostante stili di programmazione talvolta diversi.

\subsection*{Marco Magnani}
\subsection*{Manuel Baldoni}

\section{Difficoltà incontrate e commenti per i docenti}

\appendix
\chapter{Guida utente}

\chapter{Esercitazioni di laboratorio}
Elenco dei Permalink delle consegne nel forum studenti del modulo di laboratorio.
\section*{Consegne}
\subsection{luca.casadei27@studio.unibo.it}
\begin{itemize}
	\item Laboratorio 06: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=146511#p208401}
	\item Laboratorio 07: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=147598#p209323}
	\item Laboratorio 08: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=148025#p209782}
	\item Laboratorio 09: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=149231#p211336}
	\item Laboratorio 10: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=150252#p212475}
\end{itemize}

\end{document}